include::_common.adoc[]
:imagesdir: ./private_imgs/sesion2

== CDC ‚Äî Introduction

[.text-center]
*Clock Domain Crossing*

* Data crossing between two asynchronous clocks
* CDC appears in **almost every** modern SoC (multiple clocks, gating, PLLs)
* The key issue is **when** the data is sampled
* **Metastability** cannot be avoided; it can be **contained and mitigated**
* Goal of this section: understand the phenomenon and lay the groundwork for **safe CDC design**

[.notes]
--
Introducci√≥n a CDC. El CDC es el fen√≥meno que ocurre cuando los datos cruzan entre dominios de reloj as√≠ncronos. Aparece en casi todos los SoCs modernos debido a la presencia de m√∫ltiples relojes, t√©cnicas de gating y PLLs. El problema clave es cu√°ndo se muestrea el dato. La metaestabilidad no se puede evitar, pero s√≠ contener y mitigar. El objetivo de esta secci√≥n es entender el fen√≥meno y sentar las bases para un dise√±o seguro de CDC.
--

== Metastability ‚Äî What it is?

image::metastability.png[width=500,align=center]

[%step]
* A flip-flop can enter a **neither-0-nor-1** state for some time when sampling **too close** to a clock edge  
* This happens when **event ordering** (data vs. clock) is ambiguous  
* If the FF output hasn‚Äôt **resolved** before it is used ‚Üí **synchronization failure**  
* In multi-clock systems, metastability is **inevitable**; the goal is to make failures **vanishingly rare**

[.notes]
--
La metaestabilidad es un estado intermedio entre 0 y 1 que puede durar un tiempo indefinido cuando un flip-flop muestrea un dato muy cerca del flanco de reloj. Ocurre cuando el orden de los eventos (dato vs. reloj) es ambiguo. Si la salida del FF no se ha resuelto antes de ser usada, se produce una falla de sincronizaci√≥n. En sistemas con m√∫ltiples relojes, la metaestabilidad es inevitable; el objetivo es hacer que las fallas sean extremadamente raras.
--

=== Metastability ‚Äî What it is?

image::metastability.png[width=500,align=center]

[plantuml, metaestabilidad_corta, svg, width=95%]
....
@startuml
skinparam BackgroundColor transparent
skinparam DefaultFontSize 28
skinparam StrokeThickness 3
scale 1400x480

clock "clkA" as A with period 10 offset 0
concise "dataA" as D
clock "clkB" as B with period 13 offset 3
concise "FF1" as F1
concise "FF2" as F2

@0
D is low
F1 is low
F2 is low
@15.3
D is high
@16
F1 is "META" #FFEBEE;line:red
@18.5
F1 is high
@29
F2 is high
@enduml
....

=== Why is metastability a problem?

image::metastability_2.png[width=700,align=center]

[%step]
* A **metastable output** can wiggle or resolve late and **contaminate** downstream combinational logic  
* Different paths may ‚Äúsee‚Äù **different values** of the same node within the **same** time window  
* Result: **illegal values**, incoherent flags, FSMs in unreachable states

[%step]
* Every FF specifies **setup/hold**: windows during which the data must **not** change around the edge  
* Across CDC, that guarantee **does not exist** between domains ‚Üí risk of **metastability** if sampling in the forbidden window

[.notes]
--
Por que la metastabilidad es un problema? Porque la senal metaestable puede contaminar la logica combinacional aguas abajo. Si tienes varias rutas que dependen de esa senal, pueden ver valores diferentes en la misma ventana de tiempo (una ve 0, otra ve 1). Resultado: valores ilegales, flags incoherentes, FSMs en estados inalcanzables... En resumen, comportamientos raros y bugs dificiles de reproducir.
Cada flip-flop especifica tiempos de setup y hold, ventanas durante las cuales el dato no debe cambiar alrededor del flanco. En el cruce de dominios de reloj, esa garantia no existe entre dominios, lo que genera el riesgo de metastabilidad si se muestrea en la ventana prohibida.
--

== Synchronizers

[%step]
* When crossing clock domains, first ask: **do we need to capture every transition?**

[%step]
* **Scenario 1 ‚Äî Missing samples allowed**
  - You may **skip** intermediate values; sampled values must be **accurate**
  - Example: **Gray-coded pointers** in an asynchronous FIFO (must read legal values to detect *full/empty*)

[%step]
* **Scenario 2 ‚Äî No event loss allowed**
  - Every change must be **observed** (often also **acknowledged**) before the source can change again
  - Examples: control pulses, interrupts, start/commit events

[%step]
* In **both** scenarios, signals must be **synchronized** into the receiving domain

[.notes]
--
Cuando se cruzan dominios de reloj, la primera pregunta es: ¬ønecesitamos capturar cada transici√≥n? Pues aqui tenemos dos escenarios. 
Si la respuesta es no, podemos permitirnos perder muestras intermedias, siempre y cuando las muestras que tomemos sean correctas. Un ejemplo son los punteros codificados en Gray en una FIFO asincr√≥nica, donde es importante leer valores legales para detectar si la FIFO est√° llena o vac√≠a.
Si la respuesta es s√≠, no se puede perder ning√∫n evento. Cada cambio debe ser observado (y a menudo tambi√©n reconocido) antes de que la fuente pueda cambiar de nuevo. Ejemplos son pulsos de control, interrupciones, eventos de inicio/commit.
En ambos escenarios, las se√±ales deben ser sincronizadas en el dominio receptor
--

=== What is a Synchronizer?

"A synchronizer is a device that samples an asynchronous signal and outputs a version
of the signal that has transitions synchronized to a local or sample clock."

[.notes]
--
Un sincronizador es un dispositivo que muestrea una se√±al asincr√≥nica y produce una versi√≥n de la se√±al cuyas transiciones est√°n sincronizadas con un reloj local o de muestreo.
--

=== Two-Flip-Flop Synchronizer
image::sync_2FF.png[width=700,align=center]

[%step]
* The simplest and most common synchronizer used by digital designers is a two-flip-flop synchronizer
* A **synchronizer** samples an asynchronous signal and outputs a version **aligned** to the local clock
* **Stage-1 FF** samples the async input; allow one full clock for any metastability to **decay**
* **Stage-2 FF** re-samples Stage-1; output is now **stable** and safe to distribute in the new domain
* Residual risk exists (Stage-1 may still be meta at sample time), but probability drops **exponentially**
* **MTBF** depends on clock/data rates and device parameters; **two FFs** are sufficient in most designs

* üß™ Lab 1 ‚Äî Implementing a 2FF synchronizer
[%step]
* Goal: practice writing synthesizable SystemVerilog code for a 2-FF synchronizer 
* Tool: **EDAPlayground** (SystemVerilog + Questa/Verilator)  
* Concept: write a module that implements a 2-FF synchronizer

[.notes]
--
El sincronizador de dos flip-flops es el m√°s simple y com√∫nmente usado por los dise√±adores digitales. 
Un sincronizador muestrea una se√±al asincr√≥nica y produce una versi√≥n alineada con el reloj local. 
El primer flip-flop muestrea la entrada asincr√≥nica; se permite un ciclo completo de reloj para que cualquier metaestabilidad decaiga. 
El segundo flip-flop vuelve a muestrear la salida del primero; ahora la salida es estable y segura para distribuir en el nuevo dominio. 
Existe un riesgo residual (el primer FF puede seguir siendo metaestable en el momento de muestreo), pero la probabilidad disminuye exponencialmente. 
El MTBF (el tiempo medio hasta que se produce fallo) depende de las tasas de reloj/dato y de los par√°metros del dispositivo; dos FFs son suficientes en la mayor√≠a de los dise√±os.
--

=== MTBF ‚Äî Mean Time Between Failures

[stem]
++++
\mathrm{MTBF} = \frac{1}{f_{\mathrm{clk}}\, f_{\mathrm{data}}\, x}
++++

[%step]
* **Definition:** expected time until a synchronization failure in a CDC path  
* **Bigger is better:** larger MTBF ‚áí failures are **rarer**; target ‚â´ system lifetime
* **The two of the most important factors that directly impact the MTBF are:**
  - the **sample clock frequency** (how fast are signals being sampled into the receiving clock domain)
  - the **data change frequency** (how fast is the data changing that crosses the CDC boundary)
* From the above partial equation, it can be seen that failures occur more frequently in higher speed designs, or when the sampled data changes more frequently.

[.notes]
--
MTBF es el tiempo medio hasta que un CDC falla pese al sincronizador. 
Cuanto mayor sea el MTBF, m√°s raras ser√°n las fallas; el objetivo es que sea mucho mayor que la vida √∫til del sistema.
Dos de los factores m√°s importantes que afectan directamente al MTBF son la frecuencia de muestreo (qu√© tan r√°pido se muestrean las se√±ales en el dominio receptor) y la frecuencia de cambio de datos (qu√© tan r√°pido cambia el dato que cruza el l√≠mite CDC).
De la ecuaci√≥n parcial anterior, se puede ver que las fallas ocurren con m√°s frecuencia en dise√±os de mayor velocidad, o cuando el dato muestreado cambia con m√°s frecuencia.
--

=== Three flip-flop synchronizer

image::sync_3FF.png[width=700,align=center]

* For some very high speed designs, the MTBF of a two-flop synchronizer is too short and a third
flop is added to increase the MTBF to a satisfactory duration of time.

[.notes]
-- 
Para algunos dise√±os de muy alta velocidad, el MTBF de un sincronizador de dos flip-flops es demasiado corto y se a√±ade un tercer flip-flop para aumentar el MTBF a una duraci√≥n de tiempo satisfactoria.    
--

== Synchronizing signals from the sending clock domain
image::logic_2_sync.png[width=900,align=center]

[%step]
* **FAQ:** ‚ÄúDo I need to register signals in the *sending* domain?

[.notes]
--
¬øEs necesario registrar las se√±ales en el dominio de env√≠o?
--

=== Synchronizing signals from the sending clock domain
image::logic_2_sync_waves.png[width=1000,align=center]

=== Synchronizing signals from the sending clock domain

* **FAQ:** ‚ÄúDo I need to register signals in the *sending* domain?‚Äù ‚Üí **Yes, generally**
* Wrong rationale: ‚ÄúReceiver will synchronize it, so source doesn‚Äôt matter‚Äù ‚Üí **Incorrect**
* **Unregistered combinational** outputs can **glitch/settle** at the CDC boundary
* This **increases effective toggle rate** (bursts of edges) ‚Üí higher chance to sample while changing
* Result: **more metastability risk** in the receiving domain
* Rule of thumb: **register in the source domain** ‚Üí then synchronize in the destination domain

[.notes]
--
¬øEs necesario registrar las se√±ales en el dominio de env√≠o? Generalmente, s√≠.
Razonamiento incorrecto: "El receptor lo sincronizar√°, as√≠ que la fuente no importa" ‚Üí Incorrecto.
Las salidas combinacionales no registradas pueden hacer glitch o asentarse en el l√≠mite CDC. Esto aumenta la tasa efectiva de conmutaci√≥n (r√°fagas de flancos) ‚Üí mayor probabilidad de muestrear mientras cambia. Resultado: m√°s riesgo de metastabilidad en el dominio receptor.
Regla general: registrar en el dominio de origen ‚Üí luego sincronizar en el dominio de destino   
--

=== Synchronizing into the Receiving Clock Domain

[%step]
* **Register in the source domain** before the CDC boundary
* This removes **combinational settling/glitches** at the boundary
* Fewer effective edges ‚Üí lower **data-change frequency** seen by the receiver
* Lower f_data ‚Üí **higher MTBF** (longer time between failures)
* Then use a **2-FF synchronizer** in the receiving domain

[.notes]
--
Registrar en el dominio de origen antes del l√≠mite CDC. Esto elimina los glitches/asentamientos combinacionales en el l√≠mite. Menos flancos efectivos ‚Üí menor frecuencia de cambio de datos vista por el receptor. Menor f_data ‚Üí mayor MTBF (m√°s tiempo entre fallos). Luego usar un sincronizador de 2 FFs en el dominio receptor.
--

=== Synchronizing into the Receiving Clock Domain
image::logic_synced.png[width=1000,align=center]



== Synchronizing Signals
[.text-center]
if a CDC signal cannot be skipped, it is important to consider signal widths or synchronization techniques when they are
passed between clock domains.

[.notes]
--
Si una se√±al CDC no puede ser omitida, es importante considerar los anchos de se√±al o las t√©cnicas de sincronizaci√≥n cuando se pasan entre dominios de reloj.
--

=== Synchronizing Fast ‚Üí Slow Clock Domains

[%step]
* A fast-domain pulse may change **twice** between slow-domain sampling edges
* Or might be too close to the sampling edge ‚Üí **metastability risk**
* Missed events are or are not allowed?

[.notes]
--
Un evento del dominio r√°pido puede cambiar dos veces entre los flancos de muestreo del dominio lento. O puede estar demasiado cerca del flanco de muestreo, lo que genera riesgo de metastabilidad.
Otra pregunta importante: ¬øSe permiten eventos perdidos o no?
--

=== Synchronizing Fast ‚Üí Slow Clock Domains

 * When missed samples are not allowed, there are two general approaches to the problem:
   1) **Open-loop** approaches (no acknowledgment)
   2) **Closed-loop** approaches (with acknowledgment)


[.notes]
--
Cuando no se permiten muestras perdidas, hay dos enfoques generales para el problema:
1) Enfoques de bucle abierto (sin reconocimiento)
2) Enfoques de bucle cerrado (con reconocimiento)
--

=== Requirement for reliable signal passing between clock domains

* Synchronizing **slower control signals** into a **faster clock domain**
  - Generally not a problem if the faster clock domain is 1.5X the frequency (or more)
* When using a two-flip-flop synchronizer, the CDC signal must be held high for at least 1.5 times the receiving clock period.
* The "three edge" requirement:
    - **Input data values must be stable for three destination clock edges**

[.notes]
--
Sincronizar se√±ales de control m√°s lentas en un dominio de reloj m√°s r√°pido generalmente no es un problema si el dominio de reloj m√°s r√°pido es 1.5 veces la frecuencia (o m√°s).
Cuando se usa un sincronizador de dos flip-flops, la se√±al CDC debe mantenerse alta durante al menos 1.5 veces el per√≠odo del reloj receptor.
El requisito de "tres flancos": 
Los valores de los datos de entrada deben ser estables durante tres flancos del reloj de destino.
--

=== Problem - passing a fast CDC pulse to a slow clock domain
image::fast_to_slow_pulse_problem.png[width=1000,align=center]
[%step]
* A 1-cycle pulse in a **fast** domain can be **completely missed** by a **slower** domain*
* If the pulse rises and falls **between two slow edges**, the slow domain **never samples ‚Äò1‚Äô**
* A plain **2-FF synchronizer** won‚Äôt help if the slow domain **never sees the level**
* This is a **lost event** problem, not (just) metastability

[.notes]
--
Un pulso de 1 ciclo en un dominio r√°pido puede ser completamente perdido por un dominio m√°s lento. Si el pulso  es entre dos flancos, el dominio lento nunca muestrea '1'. Un simple sincronizador de 2 FFs no ayudar√° si el dominio lento nunca ve el nivel. Este es un problema de eventos perdidos, no (solo) de metastabilidad.
--

=== Problem ‚Äî ‚ÄúLong‚Äù CDC pulse‚Ä¶ but not long enough!
image::fast_to_slow_pulse_problem_2.png[width=1000,align=center]

[%step]
* *A pulse slightly wider than **Tslow** can still be **missed** by the slow domain*
* Phase-dependent corner case: pulse changes **too close** to two consecutive slow edges
* Violates **setup** on the first edge and **hold** on the next ‚Üí no stable ‚Äò1‚Äô sampled
* 2-FF sync + edge detect may see **0 ‚Üí X ‚Üí 0** ‚Üí **no pulse** reconstructed
* Rare in sim, **real** in silicon (intermittent failures)

[.notes]
--
Un pulso ligeramente m√°s ancho que Tslow a√∫n puede ser perdido por el dominio lento.
Caso l√≠mite dependiente de la fase: el pulso cambia demasiado cerca de dos flancos lentos consecutivos. Viola el setup en el primer flanco y el hold en el siguiente ‚Üí no se muestrea un '1' estable. Un sincronizador de 2 FFs + detecci√≥n de flancos puede ver 0 ‚Üí X ‚Üí 0 ‚Üí no se reconstruye el pulso. Raro en simulaci√≥n, pero real en silicio (fallas intermitentes).
--  

== Open-Loop CDC ‚Äî Stretch & Synchronize

[%step]
* Assert the CDC **pulse long enough** so the slow domain is guaranteed to sample it
* Practical rule: pulse width ‚â• **1.5√ó T_dst** (better: span **‚â• 3 dst edges**)
* Use a **2-FF synchronizer** in the destination; edge-detect there to recreate a 1-cycle pulse
* Valid only when **clock ratios/phases are fixed** and worst-case analyzed

[.notes]
--
Idea principal: Si no hay ‚Äúack‚Äù, asegura que el pulso dure lo suficiente para que el dominio lento lo muestree al menos una vez. Regla pr√°ctica: ‚â•1.5√óT_dst, m√°s robusto si cubre 3 flancos del reloj destino. Siempre sincroniza con 2 FFs y detecta flanco en el destino. Solo vale cuando las frecuencias son fijas o controladas y ya analizaste el peor caso.
--

== Open-Loop CDC ‚Äî Stretch & Synchronize
image::open_loop.png[width=1000,align=center]

=== Pros / Cons (Open-Loop)

* ‚úÖ **Fastest** CDC for single events (no handshake latency)
* ‚ö†Ô∏è **Brittle** if clocks/ratios/latencies change later
* ‚ö†Ô∏è Easy to misuse as a ‚Äúgeneral solution‚Äù ‚Äî guard with **assertions**
  - Adding a SVA to the model to detect if the "three edges" requirement is met

[source,systemverilog]
----
property p_openloop_three_edges;
  @(posedge clk_dst) disable iff (!rstn_dst)
    $rose(sig_dst_sync) |-> sig_dst_sync[*2];
endproperty
assert property (p_openloop_three_edges)
  else $error("Open-loop CDC: pulse too short for destination clock");
----

[.notes]
--
Pros y contras del enfoque de bucle abierto:
Pros: Es el CDC m√°s r√°pido para eventos √∫nicos (sin latencia de handshake).
Contras: Fr√°gil si cambian los relojes/ratios/latencias m√°s tarde. F√°cil de mal utilizar como una "soluci√≥n general": proteger con **aserciones**.
  - A√±adir un SVA al modelo para detectar si se cumple el requisito de "tres flancos". 
--

=== Closed-Loop CDC ‚Äî Handshake / Acknowledge

[%step]
* Send a **request (req)** from source domain ‚Üí **synchronize** into destination
* Then pass the synchronized signal back to source through another synchronizer.
    - This is the ACK (acknowledge)

[.notes]
-- 
La idea central es que evitamos perder eventos mandando un ‚Äúreq‚Äù que no se suelta hasta recibir ‚Äúack‚Äù del dominio destino. Sin supuestos de ratio/phase: si hay reloj, eventualmente se ve. El destino produce un pulso local de 1 ciclo para su l√≥gica y devuelve un ‚Äúack‚Äù (seguir√° el nivel de req o un pulso latcheado). El ack vuelve sincronizado al origen y entonces el origen baja req.
--

=== Closed-Loop CDC ‚Äî Handshake / Acknowledge
image::close_loop.png[width=1000,align=center]


=== Pros / Cons (Closed-Loop)

[%step]
* ‚úÖ Very **safe**: no missed events; robust vs. clock frequency/phase changes
* ‚ö†Ô∏è Extra **latency**: two synchronizers (A‚ÜíB and B‚ÜíA) ‚Üí ~4‚Äì6 cycles total
* ‚ö†Ô∏è Slightly more **logic** and control (busy/flow-control) than open-loop

[.notes]
--
Pros: Muy seguro: no hay eventos perdidos; robusto frente a cambios de frecuencia/fase de reloj.
Contras: Extra latencia: dos sincronizadores (A‚ÜíB y B‚ÜíA) ‚Üí ~4‚Äì6 ciclos en total. Un poco m√°s de l√≥gica y control (busy/flow-control) que el enfoque de bucle abierto.
--


== Passing Multiple Signals Between Clock Domains

[%step]
* Simple synchronizers do **not** guarantee safe delivery of **multi-bit** data across clock domains.
* A common mistake is sending several CDC bits for the same transaction without making sure those bits are sampled together at the same time.
* Multiple signals synchronized to one clock can have **small skews** and may be sampled on **different rising edges** in the destination clock domain.
* Even with perfectly matched trace lengths, **rise/fall-time differences** and **process variations** can introduce enough skew to cause **sampling failures**.
* Therefore, **multi-bit CDC strategies** must be used to avoid **skewed sampling** of the multi-bit value.

[.notes]
--
Los sincronizadores simples no garantizan la entrega segura de datos de varios bits a trav√©s de dominios de reloj. Un error com√∫n es enviar varios bits CDC para la misma transacci√≥n sin asegurarse de que esos bits se muestreen juntos al mismo tiempo. M√∫ltiples se√±ales sincronizadas a un reloj pueden tener peque√±os desfases y pueden ser muestreadas en diferentes flancos ascendentes en el dominio de reloj de destino. Incluso con longitudes de traza perfectamente igualadas, las diferencias de tiempo de subida/bajada y las variaciones del proceso pueden introducir suficiente desfase para causar fallos de muestreo. Por lo tanto, se deben usar estrategias CDC de varios bits para evitar el muestreo desfasado del valor de varios bits.
--

=== Multi-bit CDC Strategies ‚Äî Overview

[%step]
* To avoid **skewed sampling** on multi-bit CDC, use one of three approaches:

[%step]
1) **Multi-bit signal consolidation**  
   *Where possible, consolidate multiple CDC bits into **1-bit** CDC signals.*

[%step]
2) **Multi-cycle path formulations**  
   *Use a **synchronized load** signal to safely pass multiple CDC bits.*

[%step]
3) **Gray-code based transfer**  
   *Pass multiple CDC bits using **gray codes**.*

[.notes]
--
Para evitar el muestreo desfasado en CDC de varios bits, use uno de estos tres enfoques:
1) Consolidaci√≥n de se√±ales de varios bits: cuando sea posible, consolide m√∫ltiples bits CDC en se√±ales CDC de 1 bit.
2) Formulaciones de ruta de m√∫ltiples ciclos: use una se√±al de carga sincronizada para pasar de forma segura m√∫ltiples bits CDC.
3) Transferencia basada en c√≥digo Gray: pase m√∫ltiples bits CDC usando c√≥digos Gray.
--

== Multi-bit Signal Consolidation

[%step]
* When possible, **consolidate multiple CDC signals** into a **single-bit** CDC signal  
* Ask: ‚ÄúDo I really need **multiple bits** to control logic across a CDC boundary?‚Äù

[%step]
* Simply adding **synchronizers on every bit** is **not enough**  
* If **ordering** or **alignment** matters ‚Üí risk of misaligned sampling  

[%step]
* Goal: reduce complexity and ensure **coherent control** on the receiving side  
* This technique often avoids **skew and metastability** propagation between bits

[.notes]
--
Cuando sea posible, consolide m√∫ltiples se√±ales CDC en una sola se√±al CDC de 1 bit. Preg√∫ntese: "¬øRealmente necesito m√∫ltiples bits para controlar la l√≥gica a trav√©s de un l√≠mite CDC?"
Simplemente a√±adir sincronizadores en cada bit no es suficiente. Si el orden o la alineaci√≥n importa ‚Üí riesgo de muestreo desalineado.
El objetivo es reducir la complejidad y asegurar un control coherente en el lado receptor.  Esta t√©cnica a menudo evita la propagaci√≥n de desfases y metaestabilidad entre bits.
--

=== Problem ‚Äî Two Simultaneously Required Control Signals
image::prb1_passing_multi.png[width=1000,align=center]

=== Problem ‚Äî Two Simultaneously Required Control Signals
* Example scenario:  
  - A register in the receiving clock domain requires **two control signals** ‚Äî *load* and *enable* ‚Äî to store data  
  - Both signals are asserted in the **same sending clock edge**

* Problem: even a **tiny skew** between *load* and *enable* can cause  
  - Each signal to be **synchronized on different cycles** in the receiving clock domain  
  - The data **not being loaded** as intended

* Root cause:  
  - **Independent synchronization** of correlated control signals  
  - Lack of **guaranteed phase alignment** across the CDC boundary

[.notes]
--
Escenario de ejemplo: Un registro en el dominio de reloj receptor requiere dos se√±ales de control: load y enable, para almacenar datos. Ambas se√±ales se activan en el mismo flanco del reloj de env√≠o.
Problema: incluso un peque√±o desfase entre load y enable puede causar que cada se√±al se sincronice en ciclos diferentes en el dominio de reloj receptor, y los datos no se carguen como se pretend√≠a.
Causa ra√≠z: sincronizaci√≥n independiente de se√±ales de control correlacionadas y falta de alineaci√≥n de fase garantizada a trav√©s del l√≠mite CDC.
--

=== Solution: Multi-bit Signal Consolidation

* The fix is **simple but effective**:  
  ‚Üí **Consolidate** multiple correlated control signals into a **single CDC signal**

* Example:  
  - Replace separate *load* and *enable* signals with **one combined** *load_enable* control  
  - This unified signal drives both control inputs in the **receiving clock domain**

* Benefit:  
  - Eliminates the possibility of **time-shifted arrivals** between signals  
  - Ensures **atomic behavior** ‚Äî both actions occur together and in the correct cycle

[.notes]
--
La soluci√≥n es simple pero efectiva: consolide m√∫ltiples se√±ales de control correlacionadas en una sola se√±al CDC.
Ejemplo: Reemplace las se√±ales load y enable separadas por una sola se√±al combinada load_enable. Esta se√±al unificada controla ambas entradas de control en el dominio de reloj receptor.
Beneficio: Elimina la posibilidad de llegadas desfasadas entre se√±ales. Asegura un comportamiento at√≥mico: ambas acciones ocurren juntas y en el ciclo correcto.
--  

=== Solution: Multi-bit Signal Consolidation
image::consolidation.png[width=1000,align=center]

=== Problem ‚Äî Two Phase-Shifted Sequencing Control Signals

[%step]
* In this scenario, two enable signals (**aen1**, **aen2**) are sent **sequentially** from one clock domain to another  
* Each signal controls **pipelined data registers** in the receiving domain  
* The issue:  
  - **aen1** may **deassert** slightly before **aen2** is asserted  
  - If the receiving clock edge occurs during this **small gap**, one register‚Äôs enable input may be **inactive** for one cycle  
* Consequence:  
  - A **one-cycle hole** appears in the enable chain  
  - The **a2** data value may be **missed** by the second register  

[.notes]
--
En este escenario, dos se√±ales de habilitaci√≥n (aen1, aen2) se env√≠an secuencialmente de un dominio de reloj a otro. Cada se√±al de control llega en pipelining. El problema: aen1 puede desactivarse ligeramente antes de que se active aen2. Si el flanco del reloj receptor ocurre durante este peque√±o intervalo, la entrada de habilitaci√≥n de uno de los registros puede estar inactiva durante un ciclo. Consecuencia: aparece un hueco de un ciclo en la cadena de habilitaci√≥n y el valor de datos a2 puede perderse por el segundo registro.
--

=== Problem ‚Äî Two Phase-Shifted Sequencing Control Signals
image::passing_sequence.png[width=1000,align=center]


=== Solution: Consolidation and an extra flip-flop

* The solution to this problem, is to send only one control signal into the receiving clock domain and generate the second phase-shifted pipelined enable signal within the receiving clock domain.

image::passing_sequence_solution.png[width=1000,align=center]


== Multiple CDC Signals: problem

[%step]
* Two **encoded control signals** are transferred across different clock domains  
* Each signal represents part of a **combined code** that must be interpreted together in the receiving domain  

* The issue:  
  - Even a **small skew** between the two signals at the sampling moment can cause the receiver to capture a **mismatched combination**  
  - This produces a **temporary illegal or incorrect code** for **one clock cycle**  

* Consequence:  
  - The receiving logic may **decode** an invalid state  
  - Can trigger **incorrect operations** or **spurious control actions**

[.notes]
--
Este es un cl√°sico problema de **multi-bit CDC**: cuando varias l√≠neas cruzan a la vez, nunca llegan perfectamente alineadas.  
Si los bits representan un c√≥digo (por ejemplo, ‚Äú01‚Äù, ‚Äú10‚Äù), una peque√±a diferencia de tiempo puede hacer que el dominio receptor vea ‚Äú00‚Äù o ‚Äú11‚Äù por un ciclo.  
Eso puede activar se√±ales de control err√≥neas o estados transitorios ilegales.  
Punto clave: cada bit se sincroniza de forma independiente, pero el **conjunto** puede quedar inconsistente durante un ciclo.
--

== Multiple CDC Signals: problem
image::enc_ctrl_signal.png[width=1000,align=center]

=== Solutions for Passing Multiple CDC Signals

[%step]
* To address **multi-bit CDC issues**, designers can use:  
  - **Multi-Cycle Path (MCP)** formulations  
  - **FIFO-based** synchronization techniques  

[%step]
* MCP formulations provide **deterministic synchronization** by allowing extra clock cycles for proper data capture  
* FIFO techniques act as **closed-loop systems**, ensuring ordered and reliable data transfer across clock domains  

[%step]
* Two primary **MCP formulations**:  
  1. **Closed-loop MCP** ‚Äî with feedback  
  2. **Closed-loop MCP** ‚Äî with acknowledge feedback  

[%step]
* Two **FIFO-based** strategies:  
  1. **Asynchronous FIFO** ‚Äî decouples write and read clocks  
  2. **2-deep FIFO** ‚Äî simplified structure for smaller data crossings  

[.notes]
--
El mensaje aqu√≠ es que los **multi-bit CDC** no pueden resolverse con simples sincronizadores de 2 FF por bit.  
Las soluciones robustas usan **protocolos de control o almacenamiento temporal**:  
- Los **MCP** introducen latencia controlada y sincronizaci√≥n garantizada.  
- Los **FIFOs** separan completamente los dominios, ofreciendo una soluci√≥n de tipo ‚Äúhandshake autom√°tico‚Äù.  
Estas dos familias de soluciones ser√°n detalladas a continuaci√≥n; cada una ofrece un balance distinto entre **latencia, complejidad y robustez**.
--

== Multi-Cycle Path (MCP)

[%step]
* **MCP**: robust way to transfer **multi-bit CDC data**
* Hold data stable; send a **synchronized enable** to the destination
* Data is sampled only after enable passes through the synchronizer
* No need to stretch pulses or align edges
* As long as data stays stable until enable is seen, sampling is safe

[.notes]
--
El concepto esencial de MCP: los datos cruzan directamente sin sincronizaci√≥n, pero **no se muestrean** hasta que el *enable* sincronizado llega.  
As√≠ se evita la metaestabilidad porque el dato est√° quieto cuando se lee.  
El nombre ‚Äúmulti-cycle path‚Äù viene de que el dato se mantiene constante durante varios ciclos del reloj receptor, dando tiempo a que el control se sincronice.  
Ventaja pr√°ctica: elimina la necesidad de calcular anchos de pulso ni dependencias de frecuencia.  
Ideal para transferir palabras de control o registros peque√±os entre dominios.
--

== MCP Formulation ‚Äî Using a Synchronized Enable Pulse

[%step]
* The most common way to transfer an enable across clock domains is through a **toggling enable** signal.  
* This toggle is passed into a **synchronized pulse generator** in the receiving domain.  
* The generator produces a **single-cycle pulse** to indicate that the unsynchronized data word can be captured safely.
* This synchronized pulse effectively says:  
  ‚ÄúNew valid data is ready; sample it now.‚Äù  
* The pulse is **self-contained**, one clock wide, and safely aligned to the receiving clock domain.

[.notes]
--
La forma m√°s com√∫n de transferir un enable a trav√©s de dominios de reloj es mediante una se√±al de enable que cambia de estado (toggle). Este toggle se pasa a un generador de pulsos sincronizado en el dominio receptor. El generador produce un pulso de un solo ciclo para indicar que la palabra de datos no sincronizada puede ser capturada de forma segura. Este pulso sincronizado dice efectivamente: "Nuevos datos v√°lidos est√°n listos; muestrea ahora". El pulso es autocontenido, de un ciclo de reloj de ancho, y est√° alineado de forma segura con el dominio de reloj receptor.
--  

=== synchronized pulse generator
image::mcp_sync_pulse_gen.png[width=1000,align=center]

=== synchronized pulse generator
image::mcp_sync_pulse_gen_2.png[width=1000,align=center]

* üß™ Lab 2 ‚Äî Implementing a Synchronized Pulse Generator

[%step]
* Goal: implement the **pulse generator** used in the MCP synchronized enable method  
* Tool: **EDAPlayground** (SystemVerilog + Questa/Verilator)  
* Concept: detect a **toggle** on an input and generate a **1-cycle synchronized pulse**

=== MCP toggle-pulse generation
image::mcp_sync_pulse_gen_3.png[width=1000,align=center]

* üß™ Lab 3 ‚Äî Simulate the MCP 

=== Closed-loop MCP Formulation ‚Äî With Feedback

[%step]
* Extension of the **MCP formulation**  
* The **enable signal** is sent back to the sending clock domain as an **acknowledge** signal  
* This creates an **automatic feedback path**, assuming the receiver is **always ready**  
* Used when:
  - Continuous data transfer is expected  
  - The receiver can always accept new data  
  - No additional handshake or buffering is required

=== Closed-loop MCP Formulation ‚Äî With Feedback

image::MCP_ack.png[width=1000,align=center]

[.notes]
--
La se√±al de reconocimiento (b_ack) genera un pulso de acknowledge (aack) que se utiliza como entrada para una peque√±a FSM READY-BUSY de un solo estado. Esta FSM produce una se√±al de ready (aready) que indica cu√°ndo es seguro volver a cambiar el valor de entrada de datos (adatain). Una vez que aready se activa, el emisor puede enviar nuevos datos (adatain) y la se√±al de control asend.
--


=== Closed-loop ‚Äî MCP formulation with acknowledge feedback

[%step]
* A **fully responsive variation** of the MCP formulation  
  ‚Äî feedback is sent **only after** data has been successfully received  
* The **enable signal** is passed back to the sending domain  
  **after** the receiving domain asserts its **bload** acknowledgment  
* This ensures that the sender knows the data was not only received,  
  but also **accepted and loaded** correctly  

[%step]
* In this scheme:  
  - The receiving domain uses a small **WAIT‚ÄìREADY FSM**  
  - FSM asserts **bvalid** when data is ready to be consumed  
  - The receiver must assert **bload** to confirm data capture  
  - Only then is **b_ack** returned to the sending domain  

[%step]
* Advantage ‚Üí ensures **data integrity and flow control** across domains  
* Trade-off ‚Üí additional **latency** due to the two-way synchronization  
* Common in **robust CDC interfaces** and asynchronous handshakes  

[.notes]
--
Esta variante del MCP es la m√°s ‚Äúsegura‚Äù porque el dominio B no solo sincroniza el dato, sino que **confirma activamente** que el dato fue cargado antes de devolver el acknowledge.  
La diferencia clave con el caso anterior (feedback autom√°tico) es que aqu√≠ el **bload** viene del receptor, no es autom√°tico.  
Esto garantiza que el dominio A no env√≠e un nuevo dato hasta que B haya **completado la carga**.  
Mencionar que el coste es un poco m√°s de latencia, pero la ganancia es **fiabilidad total del handshake**.  
Esta t√©cnica se usa en interfaces as√≠ncronas, FIFOs handshake y protocolos tipo ‚Äúvalid/ready‚Äù donde cada transferencia se confirma.
--

=== Closed-loop ‚Äî MCP formulation with acknowledge feedback
image::MCP_complete.png[width=1000,align=center]

* üß™ lab 4: Simulate Closed-loop - MCP formulation with acknowledge feedback


== Synchronizing counters

[%step]
* When passing **counter values** across clock domains, ask: *‚ÄúDo I need to capture every value?‚Äù*  
  ‚Üí Often, the answer is **no**  
* Example: in **asynchronous FIFO** designs, **Gray-coded counters** are sampled between domains  
  - Intermediate Gray values may be **missed**  
  - The design remains **functionally correct**  
* Key requirement ‚Üí prevent **overrun or underrun**  so that **full** and **empty** flags remain accurate  
* As long as the **important transitions** are captured, skipping intermediate counts is acceptable  

[%step]
* ‚ö† Not every counter type is safe for CDC use  
  - **Binary counters** can toggle multiple bits at once  
  - This can cause incorrect sampling across the domain boundary  

[.notes]
--
Cuando se pasan valores de contadores a trav√©s de dominios de reloj, preg√∫ntese: "¬øNecesito capturar cada valor?" A menudo, la respuesta es no. Un ejemplo son los contadores codificados en Gray en dise√±os de FIFO as√≠ncronos, donde se pueden perder valores intermedios de Gray y el dise√±o sigue siendo funcionalmente correcto. El requisito clave es evitar el sobreflujo o subflujo para que las se√±ales de lleno y vac√≠o sigan siendo precisas. Siempre que se capturen las transiciones importantes, omitir conteos intermedios es aceptable.
--

=== Binary Counters

[%step]
* In binary counters, **multiple bits** often toggle simultaneously  
  ‚Üí Half of all increments require **two or more bits** to change  

[%step]
* Synchronizing a binary counter across a CDC boundary  
  = synchronizing **multiple signals** at once  

[%step]
* Example: transition `0111 ‚Üí 1000`  
  ‚Üí all **four bits** toggle simultaneously  
  ‚Üí receiver clock may sample an **illegal intermediate value**  

[%step]
* Consequences in FIFO designs:  
  - May trigger **false full/empty** flags  
  - May **miss real flags**, causing  
    ‚Ä¢ **Data loss** (overflow)  
    ‚Ä¢ **Invalid reads** (underflow)

[.notes]
--
En los contadores binarios, a menudo se conmutan varios bits simult√°neamente: la mitad de todos los incrementos requieren que dos o m√°s bits cambien. Sincronizar un contador binario a trav√©s de un l√≠mite CDC equivale a sincronizar m√∫ltiples se√±ales a la vez. Un ejemplo es la transici√≥n 0111 ‚Üí 1000, donde los cuatro bits cambian simult√°neamente. El reloj receptor puede muestrear un valor intermedio ilegal. Las consecuencias en dise√±os FIFO pueden ser se√±ales de lleno/vac√≠o falsas o perder se√±ales reales, causando p√©rdida de datos (overflow) o lecturas inv√°lidas (underflow).
--

=== Binary Counters

image::binary_counter.png[width=1000,align=center]

=== Gray Code Counters

[%step]
* In a **Gray code**, only **one bit changes per increment**
* This eliminates the multi-bit sampling hazards seen in **binary counters**
* Ideal for **asynchronous FIFO pointers** and **multi-clock systems**
* Easy **gray ‚Üî binary** conversions make implementation straightforward


[.notes]
--
En un c√≥digo Gray, solo cambia un bit por incremento. Esto elimina los peligros de muestreo de m√∫ltiples bits vistos en los contadores binarios. Es ideal para punteros FIFO as√≠ncronos y sistemas de m√∫ltiples relojes. Las conversiones f√°ciles entre gray y binario hacen que la implementaci√≥n sea sencilla.
--

=== Gray Code Counters

* Standard gray codes have very nice translation properties to convert gray-to-binary and back
again. Using these conversions, it is simple to design efficient gray code counters.