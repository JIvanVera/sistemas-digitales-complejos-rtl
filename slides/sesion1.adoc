include::_common.adoc[]
:imagesdir: ./private_imgs/sesion1

== Introduction

[.text-center]
*Resets — simple in appearance, complex in practice*

[%step]
* Reset design is often **underestimated** in formal education  
* Improper reset strategies → **real issues in industry**  
* Choosing synchronous vs. asynchronous reset has become an almost **religious debate**  
* Both approaches are valid — each with **strengths and weaknesses**

== ⚡Goal
[%step]
[.text-center]
Understand *why resets matter*, the trade-offs of each style,  
and how to make an **informed design choice**.

== Why Resets Matter

[%step]
* Define a **known starting state** for simulation and silicon  
* Guarantee **deterministic behavior** after power-up  
* Enable **system recovery** after faults or loss of sync
* Impact on **reliability, testability, and synthesis**

== Reset Misconceptions

[%step]
* "Resets are trivial" → reality: design choice impacts **timing, area, testability**  
* "Only one right way" → reality: **synchronous and asynchronous** both valid  
* "Resets are only for simulation" → reality: critical for **system-level integration**

== Purpose of Resets

[%step]
* Resets bring a system back to a **known working state**  
  → e.g. after a crash, power-up, or sync loss  

[%step]
* For ASICs, resets force the design into a **known initial state**  
  - Simulation (behavioral, RTL, structural)  
  - Power-up initialization  
  - Recovery from “don’t care” logic optimizations

[%step]
* Data-path ASICs may recover sync **without external resets**  
  if state machines are well designed

== Reset Design Considerations

[%step]
* Should **every flip-flop** be reset?  
  - Yes (general case)  
  - Exception: pipeline flip-flops in high-speed paths  

[%step]
* Key challenges:  
  - Synchronous vs. asynchronous reset strategy  
  - Reset distribution (tree layout & buffering)  
  - Timing verification of reset paths  
  - Scan-test of reset logic  
  - Coordinating resets across multiple clock domains

== ⏱ Synchronous Resets

[%step]
* Reset **only takes effect** on the active clock edge  
* Implemented as part of the **combinational logic** feeding *D*  

[%step]
* Coding style → `if (reset)` has **highest priority**  
* Otherwise: risk of  
  - Reset blocked in simulation  
  - **Late arrival** of reset (high fanout in reset tree)  

[%step]
* Even with reset buffer trees →  
  **Minimize logic delay** after the reset reaches local logic  

[%step]
* Works with **any logic library**  
* Example: loadable counter with synchronous reset + carry-out

== Synchronous Reset Coding Style

[%step]
* Always put **reset first** in the `if` condition  
* Reset has **highest priority** over all other logic  
* Guarantees known state in **simulation**  
* Synthesizes cleanly with **any logic/library**  
* After reset → other logic (`load`, `enable`, `increment`, …)

== Example: Counter

[%notitle,stretch]
[source,systemverilog]
----
module ctr8sr (
  input  logic        clk,
  input  logic        rst_n,  // active low reset
  input  logic        load,
  input  logic [7:0]  d,
  output logic [7:0]  q,
  output logic        co
);
  always_ff @(posedge clk) begin
    if (!rst_n)         // sync reset
      {co,q} <= '0;
    else if (load)      // sync load
      {co,q} <= d;
    else                // sync increment
      {co,q} <= q + 1'b1;
  end
endmodule
----
*Loadable counter with synchronous reset*

== example circuit 1

image::count_sync_rst.0.png[width=500, align=center]


== Is this signal a reset?
* One problem with the sync reset is that the synt tool cannot easily distinguish the reset signal from other data signal


== example circuit 2

image::count_sync_rst.1.png[width=500, align=center]

== Synopsys compiler directive: Reset Logic Inference
* To enable the tool to recognize reset signals and infer proper reset logic, you can use the:
- sync_set_reset directive 
- hdlin_ff_always_sync_set_reset variable


== Advantages of synchronous resets (Part I)

* Flip-flops with synchronous reset can be smaller → reset logic merged into D-input
* Generally insure that the circuit is 100% synchronous.
* Reset only occurs on a clock edge → clock filters small glitches
  - This is no different or worse than every other data input; any signal that violates setup requirements can cause metastability

== Advantages of synchronous resets (Part II)
* Useful when reset must be generated by internal conditions → filters combinational glitches
* Reset buffer tree can use flip-flops → helps timing within a clock period
* Claimed to be easier in cycle-based simulators
  - But with good testbench practice, advantage is minimal
* Overall: synchronous reset is robust, but not always decisive for area or simulation speed

== ⚠ Disadvantages of Synchronous Resets (Part I)

[%step]
* Not all libraries include flip-flops with built-in sync reset.
  -  However since synchronous reset is just another data input, you don’t really need a special flop
* May need a **pulse stretcher** to guarantee reset width across clock edges.
 - This is an issue that is important to consider when doing multi-clock design. A small counter can be used that will guarantee a reset pulse width of a certain number of cycles.


== ⚠ Disadvantages of Synchronous Resets (Part II)

* In simulation, resets can be masked by **X-propagation** through logic  
* Requires a **clock** to take effect → problematic with gated clocks or no clock running  
* On power-up with **tristate buses**, async reset is safer (avoids contention)  

== ⚠ On power-up with **tristate buses**
image::rst_buf_tris.png[width=700, align=center]

== ⏱ Asynchronous Resets

[%step]
* Commonly used because reset acts **immediately**, independent of clock  
* Flip-flops usually provide a **dedicated reset pin** (typically active-low)  
* Ensures logic goes to a **known state** as soon as reset is asserted  

== ⚠ Risks of Asynchronous Resets

[%step]
* Main issue: **reset release / removal**  
  - If not handled properly → risk of metastability & design failures  
* Sensitive to timing between **reset de-assertion** and **clock edges**  
* Requires careful design practices to ensure reliable behavior  

== Coding Style for Asynchronous Reset

[%step]
* Reset must be part of the **sensitivity list**  
* Sensitivity only to:  
  - **Clock edge**  
  - **Reset edge**  
* Reset must have **priority** over other logic (if/else style)  
* Avoid adding extra signals to the sensitivity list → incorrect simulation  

== Example: Async Reset Flip-Flop

[source,systemverilog]
----
module async_resetFFstyle (
  output logic q,
  input  logic d, clk, rst_n
);

always_ff @(posedge clk or negedge rst_n) begin
  if (!rst_n)
    q <= 1'b0;      // async reset
  else
    q <= d;         // normal operation
end

endmodule
----

== Async Reset in Synthesis (Synopsys DC)

[%step]
* Reset nets must be **protected** from optimization
* If reset comes from an **external pin**:
  - `set_drive 0 [get_ports reset]`
  - `set_dont_touch_network [get_nets reset]`

[%step]
* Alternative approaches:
  - `set_resistance 0 [get_nets reset]`
  - Custom *wireload model* with `resistance=0`
  - `set_ideal_net reset` (post-2001.08)

[%step]
* To clean timing reports:
  - `set_disable_timing [get_nets reset]`
  - `set_false_path -from [get_ports reset]`

[.text-center]
⚠️ Goal: Ensure reset nets are **not modified** and  do not introduce false timing violations

== Advantages of Asynchronous Resets

[%step]
* **Timing advantage**:  
  → No extra gates or net delays in the data path

[%step]
* **Independent of clock**:  
  → Circuit can be reset even when clock is not present

[%step]
* **Synthesis-friendly**:  
  → With proper coding style, tools infer async-reset flops automatically

== Disadvantages of Asynchronous Resets

[%step]
* **DFT concern**  
  → If not driven from I/O pin, reset nets must be disabled for scan/testing

[%step]
* **Static Timing Analysis (STA) complexity**  
  → Reset tree must be checked for both async & sync timing  
  → Especially critical after layout
  ⚠️ This timing analysis can be eliminated if the design uses the distributed reset synchronizer flip-flop tree

== Disadvantages of Asynchronous Resets

[%step]
* **De-assertion hazard**  
  → If released near active clock edge → risk of **metastability**

[%step]
* **Noise sensitivity**  
  → Glitches or board-level noise can cause spurious resets

[%step]
* Remember: **assertion is safe, de-assertion is the real problem**

== Asynchronous Reset Problem

[%step]
* Common **misconception**:  
  → "FPGAs don’t have the same reset issues as ASICs" ❌

[%step]
* Truth: **Both FPGA and ASIC** can fail if reset is released near a clock edge

[%step]
* Flip-flops can go **metastable** → reset loses its purpose

== Asynchronous Reset Problem

[%step]
* In **simulation** → reset always works (controlled environment)  
* In **real system** → reset release can occur close to clk edge

[%step]
* Result: **intermittent, hard-to-debug failures**  
* System may enter an **unknown state**

== Key Lesson

[%step]
* Reset release must be carefully controlled  
* Avoid de-assertion near clock edges

[%step]
* Applies to both:
  - **Asynchronous resets**  
  - **Synchronous resets** (must keep edges away from clk)

== Reset Recovery Time

[%step]
* Time between **reset de-assertion** and next **clock edge**
* Equivalent to a **setup time (tsu)**:  
  → Reset inactive setup before CLK↑

[%step]
* If violated →  
  - Signal integrity issues  
  - **Metastability** in FF outputs

[%step]
* SystemVerilog (IEEE 1800-2017 supports checks:  
  - `$recovery`, `$removal`, `$recrem`

== Reset Removal Across Flip-Flops

[%step]
* When reset removal is **asynchronous to clk**
* Small **propagation delay differences** (reset vs clk) →  

[%step]
* Some flip-flops leave reset **earlier than others**
* Risk: registers exit reset state in **different clock cycles**

== Reset Removal Across Flip-Flops

⚠️ ⚠️ **EVERY ASIC USING AN ASYNCHRONOUS RESET SHOULD INCLUDE A RESET SYNCHRONIZER CIRCUIT!!**⚠️ ⚠️ 


== Reset Synchronizer: Why?

[%step]
* Asynchronous resets **work fine in simulation**... but may fail in real hardware  
* Without synchronization, reset **release near a clock edge → metastability**  
* Need a method that ensures:  
  - Fast **asynchronous assertion**  
  - Safe **synchronous de-assertion**

== Reset Synchronizer: Circuit

image::rst_sync.png[width=500, align=center]


== Reset Synchronizer: Circuit

[%step]
* External reset asynchronously resets two FFs  
* These FFs drive the **master reset** across the design  
* De-assertion is synchronized → requires **2 clock cycles**  
* Second FF protects against metastability  
* Synchronizer FFs must be kept **off scan chain**

== Reset Synchronizer: Timing
image::rst_sync_II.png[width=500, align=center]
* eset distribution timing is the sum of the a clk-to-q propagation delay

== Reset Synchronizer: Timing

[%step]
* Reset distribution timing =  
  **clk→q delay** + **reset tree delay** + **reset recovery time**  
* Ensures all destination FFs see reset release **safely aligned**  
* Avoids asynchronous hazards across reset tree

== Reset Synchronizer. Lab 1

 idea, run simulacion without reset sincronizer using asyn reset ff

== Reset Distribution Tree

[%step]
* The **reset distribution tree** needs almost as much care as the **clock tree**
* Typically, there are as many reset loads as clock loads
* Key difference:
  - Clock skew must be tightly controlled
  - Reset skew is less critical — but **must still meet recovery time**
* Design tip:
  - Always analyze **clock vs. reset timing**
  - Reset should not violate setup/hold on flip-flops
* Ignoring reset tree design can lead to **unpredictable behavior**

== Synchronous Reset Distribution

[%step]
* Technique: build a **distributed reset tree** with embedded flip-flops  
* Each module:
  - Receives a raw reset (`reset_raw`)
  - Registers it once with the local clock
  - Uses the registered signal (`reset`) inside the module and passes it down

[%step]
* Advantages:
  - No need to reach all FFs in one clock cycle
  - Reset treated like any other **data signal**
  - Simplifies **timing analysis** and keeps fanout reasonable
* Trade-off:
  - Reset may take **several cycles** to fully propagate
  - Similar to handling resets in **multi-clock designs**

== Asynchronous Reset Distribution

[%step]
* Technique: use a **distributed reset synchronizer** at each hierarchy level  
  - 2 FFs per synchronizer (async assert, sync de-assert)  
  - Local reset drives **async reset pins** directly  

[%step]
* Characteristics:
  - Reset asserted immediately (async)  
  - Reset released gradually across multiple clock cycles  
  - Removes need for manual timing fixes after P&R  

[%step]
* Considerations:
  - Design must tolerate staggered release  
  - Proper tool settings required to check **recovery/removal** timing  
  - Especially useful in **FPGA** designs:  
    • Avoids LUT usage from sync resets  
    • Works with limited Global Set/Reset resources

== Reset Synchronizer: Timing
image::rst_sync_tree.png[width=500, align=center]


== Reset-Glitch Filtering

[%step]
* Problem: **asynchronous resets** are sensitive to glitches  
  - Any pulse wider than min. reset width will reset the FF  

[%step]
* Possible solution: **digital delay filter**  
  - Delay line filters out short glitches  
  - Requires Schmitt-trigger input pad  
  - Vendor hard-macro or hand-instantiated delay  

[%step]
* Caveats:  
  - Delay varies with **PVT (process, voltage, temperature)**  
  - Must use *dont_touch* or equivalent to prevent optimization  
  - Only needed in systems with noisy reset sources

== Multi-Clock Reset Issues

[%step]
* Each **clock domain** needs its own:  
  - Asynchronous reset synchronizer  
  - Reset distribution tree  

[%step]
* **Assertion** of reset is safe → affects all domains immediately  
* **Removal** of reset is the challenge:  
  - Must ensure recovery time per domain  
  - Avoid unsynchronized startup  

[%step]
* Two possible approaches:  
  1. **Non-coordinated reset removal** (each domain independently)  
  2. **Sequenced coordination** (controlled release across domains)

== Non-Coordinated Reset Removal

[%step]
* In many **multi-clock designs**, the exact moment when reset is removed in each domain **does not matter**  
* Safe when **cross-domain communication** uses:  
  - Request/Acknowledge handshaking  
  - Delay in ack signals does not cause invalid execution  

[%step]
* Solution:  
  - Use **independent asynchronous reset synchronizers**  
  - Each clock domain (A, B, C…) has its own reset (arst_n, brst_n, crst_n)  
  - Removal sequence/order is irrelevant

== Sequenced Reset Removal

[%step]
* Some **multi-clock designs** require **ordered reset removal**  
* Example:  
  - aclk logic must start **before** bclk logic  
  - bclk logic must start **before** cclk logic  

[%step]
* Solution:  
  - Use **prioritized asynchronous reset synchronizers**  
  - Highest priority reset input tied **high**  
  - Lower domains’ resets chained to **master resets** from higher domains

== Conclusions

[%step]
* Both **synchronous** and **asynchronous resets** can guarantee safe initialization  
* Biggest challenge → **asynchronous reset removal** (risk of metastability)  
* Recommended:  
  - Use **reset synchronizer logic**  
  - Ensure **synchronous removal** after async assertion  
* DFT with async resets is still possible if reset is **controllable during test**  
* Distributed reset flip-flop trees help with **buffering, timing & layout**  

[.text-center]
*In short: simple little resets... aren’t!* ⚡

== References

* *Asynchronous & Synchronous Reset Design Techniques – Part Deux*  
  Clifford E. Cummings, Don Mills, Steve Golson  

* *DC Synopsys User Guide*  

* *HDL Compiler™ for SystemVerilog – User Guide*  
