include::_common.adoc[]
:imagesdir: ./private_imgs/sesion1

== Introduction

[.text-center]
*Resets — simple in appearance, complex in practice*

[%step]
* Reset design is often **underestimated** in formal education
* Improper reset strategies → **real issues in industry**
* Choosing synchronous vs. asynchronous reset has become an almost **religious debate**
* Both approaches are valid — each with **strengths and weaknesses**

[.notes]
--
Hoy arrancamos con una idea simple: los resets parecen triviales, pero en la práctica esconden decisiones que impactan fiabilidad, timing y test.  
En la industria, fallos intermitentes tras power-up o tras una caída suelen tener su raíz en un reset mal planteado.  
No vamos a “elegir bando” entre síncrono o asíncrono; veremos pros, contras y cómo decidir según el contexto.
--

== ⚡Goal
[%step]
[.text-center]
Understand *why resets matter*, the trade-offs of each style,  
and how to make an **informed design choice**.

[.notes]
--
Objetivo de la sesión: que sepáis reconocer cuándo cada estilo de reset tiene sentido, qué riesgos hay y cómo mitigarlos.  
Al final deberíais poder justificar vuestra elección de reset con criterios técnicos, no con dogmas.
--

== Why Resets Matter

[%step]
* Define a **known starting state** for simulation and silicon
* Guarantee **deterministic behavior** after power-up
* Enable **system recovery** after faults or loss of sync
* Impact on **reliability, testability, and synthesis**

[.notes]
--
Un reset establece el estado inicial: evita X’s en sim y estados aleatorios en silicio.  
Tras power-up y ante fallos, permite volver a un punto conocido.  
También condiciona la testabilidad (DFT) y hasta cómo sintetiza la lógica.
--

== Reset Misconceptions

[%step]
* "Resets are trivial" → reality: design choice impacts **timing, area, testability**
* "Only one right way" → reality: **synchronous and asynchronous** both valid
* "Resets are only for simulation" → reality: critical for **system-level integration**

[.notes]
--
Mitos comunes: que da igual cómo se haga, o que sólo sirve para simular.  
En realidad, el estilo de reset cambia el timing, el área y el esfuerzo de verificación; y es clave a nivel de sistema, no sólo de módulo.
--

== Purpose of Resets

[%step]
* Resets bring a system back to a **known working state**  
  → e.g. after a crash, power-up, or sync loss

[%step]
* For ASICs, resets force the design into a **known initial state**
  - Simulation (behavioral, RTL, structural)
  - Power-up initialization
  - Recovery from “don’t care” logic optimizations

[%step]
* Data-path ASICs may recover sync **without external resets**  
  if state machines are well designed

[.notes]
--
No todo chip necesita un reset externo para operar, pero casi todos lo agradecen para arrancar de forma determinista.  
En datapaths, si las FSMs están bien diseñadas, pueden re-sincronizarse; aún así, el resto del sistema debe quedar en estado seguro.
--

== Reset Design Considerations

[%step]
* Should **every flip-flop** be reset?
  - Yes (general case)
  - Exception: pipeline flip-flops in high-speed paths

[%step]
* Key challenges:
  - Synchronous vs. asynchronous reset strategy
  - Reset distribution (tree layout & buffering)
  - Timing verification of reset paths
  - Scan-test of reset logic
  - Coordinating resets across multiple clock domains

[.notes]
--
Como regla, reseteamos todo; excepción: followers de pipelines críticos para frecuencia.  
Además del estilo, hay que diseñar el árbol de distribución, verificar recovery/removal, contemplar DFT y pensar en dominios de reloj múltiples.
--

== ⏱ Synchronous Resets

=== Concept

[%step]
* Reset **only takes effect** on the active clock edge
* Implemented as part of the **combinational logic** feeding *D*

[%step]
* Coding style → `if (reset)` has **highest priority**
* Otherwise: risk of
  - Reset blocked in simulation
  - **Late arrival** of reset (high fanout in reset tree)

[%step]
* Even with reset buffer trees → **Minimize logic delay** after the reset reaches local logic
* Works with **any logic library**

[.notes]
--
En síncrono, el reset se evalúa en el flanco de reloj; el reloj actúa como filtro natural de glitches.  
Codificad siempre el reset primero en el `if`. Limitad la lógica tras el reset local, porque el árbol suele tener gran fanout.
--

=== Example: Counter (sync reset)

[%notitle,stretch]
[source,systemverilog]
----
module ctr8sr (
  input  logic        clk,
  input  logic        rst_n,  // active low reset
  input  logic        load,
  input  logic [7:0]  d,
  output logic [7:0]  q,
  output logic        co
);
  always_ff @(posedge clk) begin
    if (!rst_n)         // sync reset
      {co,q} <= '0;
    else if (load)      // sync load
      {co,q} <= d;
    else                // sync increment
      {co,q} <= q + 1'b1;
  end
endmodule
----
*Loadable counter with synchronous reset*

[.notes]
--
Ejemplo canónico: prioridad al reset, luego al load, y por último al incremento.  
Fijaos que el reset viaja como dato hasta el D del flop: esto influye en inferencia y temporización.
--

=== Example circuit 1

image::count_sync_rst.0.png[width=500,align=center]

[.notes]
--
Aquí se ve cómo la herramienta interpreta el reset como parte de la lógica de datos.  
Esto puede confundir la inferencia si no marcamos la intención.
--

=== Is this signal a reset?

* One problem with the sync reset is that the **synthesis tool** cannot easily distinguish the reset signal from other data signals.

[.notes]
--
Mensaje: para el sintetizador, un “if (reset)” es lógica como cualquier otra.  
Conviene ayudar con directivas si queréis un tratamiento específico.
--

=== Example circuit 2

image::count_sync_rst.1.png[width=500,align=center]

[.notes]
--
Después de inferencia, vemos cómo se inserta la selección entre reset y dato.  
Esto explica el posible impacto en profundidad lógica de la ruta de datos.
--

=== Synopsys: Reset Logic Inference

* To enable the tool to recognize reset signals and infer proper reset logic, you can use:
  - `sync_set_reset` directive
  - `hdlin_ff_always_sync_set_reset` variable

[.notes]
--
En Synopsys, estas opciones facilitan que el reset se identifique e infiera como tal.  
Aun así, base fundamental: estilo de codificación limpio, con reset de mayor prioridad.
--

=== Advantages of synchronous resets (Part I)

* Flip-flops with synchronous reset can be smaller → reset logic merged into D-input
* Generally ensures the circuit is **100% synchronous**
* Reset only occurs on a clock edge → clock filters small glitches
  - This is no different than other data inputs; any signal that violates setup can cause metastability

[.notes]
--
Ventaja clave: diseño completamente síncrono y con filtro natural de glitches.  
El tamaño del flop puede ser menor si la librería no necesita pin dedicado.
--

=== Advantages of synchronous resets (Part II)

* Useful when reset must be generated by **internal conditions** → filters combinational glitches
* Reset buffer tree can use **flip-flops** → helps timing within a clock period
* Claimed to be easier in cycle-based simulators
  - But with good testbench practice, advantage is minimal
* Overall: robust, but not always decisive for area or simulation speed

[.notes]
--
Si vuestro reset viene de lógica interna, el estilo síncrono ayuda a filtrar transitorios.  
El árbol puede “registrarse” por niveles y simplificar timing; la ventaja en simulación es secundaria si el TB está bien escrito.
--

=== ⚠ Disadvantages of synchronous resets (Part I)

[%step]
* Not all libraries include flip-flops with built-in sync reset  
  - However, since sync reset is just another data input, you don’t really need a special flop
* May need a **pulse stretcher** to guarantee reset width across clock edges
  - Important in multi-clock design: a small counter can guarantee N cycles of reset

[.notes]
--
Si el pulso de reset es estrecho, puede no coincidir con ningún flanco: estiradlo con un pequeño contador.  
No dependáis de supuestos optimistas sobre anchura de pulso.
--

=== ⚠ Disadvantages of synchronous resets (Part II)

* In simulation, resets can be masked by **X-propagation** through logic
* Requires a **clock** to take effect → problematic with gated clocks or no clock running
* On power-up with **tristate buses**, async reset is safer (avoids contention)

[.notes]
--
Con relojes parados o con gating, el reset síncrono puede no surtir efecto a tiempo.  
En buses triestado al encender, el asíncrono evita contenciones antes del primer flanco útil.
--

=== ⚠ On power-up with tristate buses

image::rst_buf_tris.png[width=700,align=center]

[.notes]
--
Si mantenéis estilo síncrono, desactivad directamente las salidas triestado con el reset para garantizar alta impedancia desde el arranque.
--

== ⏱ Asynchronous Resets

=== Concept & risks

[%step]
* Commonly used because reset acts **immediately**, independent of clock
* Flip-flops usually provide a **dedicated reset pin** (typically active-low)
* Ensures logic goes to a **known state** as soon as reset is asserted

[%step]
* Main issue: **reset release / removal**
  - If not handled properly → risk of metastability & design failures
* Sensitive to timing between **reset de-assertion** and **clock edges**
* Requires careful design practices

[.notes]
--
La gran ventaja es la inmediatez; el gran riesgo es la desactivación cerca del flanco de reloj.  
Ahí es donde aparece la metastabilidad si no se sincroniza correctamente.
--

=== Coding Style for Async Reset

[%step]
* Reset must be part of the **sensitivity list**
* Sensitivity only to:
  - **Clock edge**
  - **Reset edge**
* Reset has **priority** (if/else style); avoid extra signals in the sensitivity list

[.notes]
--
Usad `always_ff @(posedge clk or negedge rst_n)` para activo-bajo.  
Sólo reloj y reset en la lista; el reset en el `if` con prioridad máxima.
--

=== Example: Async Reset Flip-Flop

[source,systemverilog]
----
module async_resetFFstyle (
  output logic q,
  input  logic d, clk, rst_n
);

always_ff @(posedge clk or negedge rst_n) begin
  if (!rst_n)
    q <= 1'b0;      // async reset
  else
    q <= d;         // normal operation
end

endmodule
----

[.notes]
--
Ejemplo directo de estilo correcto.  
Observad que el comportamiento de reset no depende del reloj para **entrar** en reset, pero sí sincronizaremos la **salida** de reset después.
--

=== Async Reset in Synthesis (Synopsys DC)

[%step]
* Reset nets must be **protected** from optimization
* If reset comes from an **external pin**:
  - `set_drive 0 [get_ports reset]`
  - `set_dont_touch_network [get_nets reset]`

[%step]
* Alternative approaches:
  - `set_resistance 0 [get_nets reset]`
  - Custom *wireload model* with `resistance=0`
  - `set_ideal_net reset` (post-2001.08)

[%step]
* To clean timing reports:
  - `set_disable_timing [get_nets reset]`
  - `set_false_path -from [get_ports reset]`

[.text-center]
⚠️ Goal: Ensure reset nets are **not modified** and do not introduce false timing violations

[.notes]
--
Proteger la red de reset para que el sintetizador no la “optimice”.  
Además, limpiad informes con `false_path` o `disable_timing` donde tenga sentido, evitando falsos positivos.
--

=== Advantages of Async Resets

[%step]
* **Timing advantage** → No extra gates/net delays in the **data path**
* **Independent of clock** → Can reset even when clock is absent
* **Synthesis-friendly** with proper coding style

[.notes]
--
Si vais justos de timing en el datapath, el asíncrono evita meter puertas extra.  
Además permite resetear subsistemas aunque su reloj aún no esté activo.
--

=== Disadvantages of Async Resets

[%step]
* **DFT concern** → If not driven from I/O pin, reset nets must be disabled for scan/testing
* **Static Timing Analysis complexity**
  - Reset tree checked for both async & sync timing, especially **after layout**
  - This can be reduced using a **distributed reset synchronizer** tree

[%step]
* **De-assertion hazard** → near active clock edge → **metastability**
* **Noise sensitivity** → glitches may cause spurious resets
* Remember: **assertion is safe; de-assertion is the real problem**

[.notes]
--
La clave: sincronizar la **salida** del reset para evitar metastabilidad.  
En STA, aseguraos de habilitar arcos de recovery/removal y revisar tras P&R.
--

== Asynchronous Reset Problem

=== Reality check

[%step]
* Common **misconception**: “FPGAs don’t have the same reset issues as ASICs” ❌
* Truth: **Both FPGA and ASIC** can fail if reset is released near a clock edge
* Flip-flops can go **metastable** → reset loses its purpose

[.notes]
--
Esto no es un “problema sólo de ASICs”.  
Las FPGAs sufren exactamente el mismo riesgo de metastabilidad si sueltas el reset cerca del flanco.
--

=== Simulation vs. Silicon

[%step]
* In **simulation** → reset always works (controlled environment)
* In **real system** → reset release can occur close to clk edge
* Result: **intermittent, hard-to-debug failures**; system may enter an **unknown state**

[.notes]
--
La sim no reproduce jitter/ruido real.  
En hardware aparecen fallos intermitentes y difíciles de reproducir: síntoma típico de un release mal sincronizado.
--

=== Key Lesson

[%step]
* Reset release must be carefully controlled; avoid de-assertion near clock edges
* Applies to both:
  - **Asynchronous resets**
  - **Synchronous resets** (must keep edges away from clk)

[.notes]
--
Mensaje para llevarse: controlad la salida de reset.  
Incluso en síncrono, aseguraos de que los bordes no caen justo en el flanco activo.
--

== Timing Considerations

=== Reset Recovery Time

[%step]
* Time between **reset de-assertion** and next **clock edge**
* Equivalent to a **setup time (tsu)**: Reset inactive setup before CLK↑

[%step]
* If violated → signal integrity issues and **metastability** in FF outputs

[%step]
* SystemVerilog (IEEE 1800-2017) supports checks:
  - `$recovery`, `$removal`, `$recrem`

[.notes]
--
El “recovery” es como un setup del reset respecto al flanco.  
Usad `$recovery/$removal/$recrem` para chequear que estáis dentro de margen.
--

=== Reset Removal Across Flip-Flops

[%step]
* When reset removal is **asynchronous** to clk, small differences in propagation (reset vs. clk) →
* Some flip-flops leave reset **earlier than others**
* Risk: registers exit reset state in **different clock cycles**

[.notes]
--
Pequeñas diferencias de ruta pueden hacer que unos FF salgan de reset uno o dos ciclos antes que otros.  
Si no lo tenéis en cuenta, podéis arrancar el sistema en un estado inconsistente.
--

== Reset Synchronizer

=== Why?

[%step]
* Async resets **work in sim**… but may fail in hardware on de-assertion
* Need **async assert** + **sync de-assert**
* Standard solution: **2-FF reset synchronizer**

[.notes]
--
Patrón universal: 2 FFs en serie por dominio de reloj para “entregar” el release alineado al flanco.  
Así mantenemos la rapidez del asíncrono al entrar y la seguridad del síncrono al salir.
--

=== Circuit

image::rst_sync.png[width=500,align=center]

[%step]
* External reset asynchronously resets two FFs
* These FFs drive the **master reset** across the design
* De-assertion is synchronized → requires **2 clock cycles**
* Second FF protects against metastability
* Synchronizer FFs must be kept **off scan chain**

[.notes]
--
Primer FF puede quedar meta si el release cae cerca del flanco; el segundo absorbe ese meta.  
Recordad: excluid estos FFs del scan o tratadlos como “safe” en DFT.
--

=== Timing

image::rst_sync_II.png[width=500,align=center]

* Reset distribution timing is the sum of **clk→q** propagation delay + **reset tree delay** + **recovery time**

[.notes]
--
Para que todos salgan seguros, la suma clk→q del sincronizador, más el retardo del árbol, más el recovery en destino, debe cumplir margen.  
Esto se verifica tras P&R.
--

=== Timing (summary)

[%step]
* Reset distribution timing = **clk→q delay** + **reset tree delay** + **reset recovery time**
* Ensures all destination FFs see reset release **safely aligned**
* Avoids asynchronous hazards across reset tree

[.notes]
--
Resumen visual: liberamos reset de forma síncrona y lo distribuimos cumpliendo recovery en todos los endpoints.  
Así evitamos salidas descoordinadas del reset.
--

=== Lab idea

* Run a simulation **without** a reset synchronizer, using async-reset FFs
* De-assert reset near a clk edge and observe behavior vs. **with** synchronizer

[.notes]
--
Demostración rápida: sin sincronizador veréis X’s/glitches en salidas; con 2 FFs, el arranque es repetible y limpio.  
Ideal para “vender” internamente la necesidad del patrón.
--

== Reset Distribution Tree

=== Overview

[%step]
* The **reset distribution tree** needs almost as much care as the **clock tree**
* Typically, there are as many reset loads as clock loads
* Key difference:
  - Clock skew must be tightly controlled
  - Reset skew is less critical — but **must still meet recovery time**
* Design tip:
  - Always analyze **clock vs. reset timing**
  - Reset should not violate setup/hold on flip-flops
* Ignoring reset tree design can lead to **unpredictable behavior**

[.notes]
--
El árbol de reset no exige skew tan ajustado como el de reloj, pero sí llegar a tiempo para cumplir recovery.  
Comparad rutas de reloj y reset y evitad violaciones de setup/hold en destinos.
--

=== Synchronous Reset Distribution

[%step]
* Technique: build a **distributed reset tree** with embedded flip-flops
* Each module:
  - Receives a raw reset (`reset_raw`)
  - Registers it once with the local clock
  - Uses the registered signal (`reset`) inside the module and passes it down

[%step]
* Advantages:
  - No need to reach all FFs in one clock cycle
  - Reset treated like any other **data signal**
  - Simplifies **timing analysis** and keeps fanout reasonable
* Trade-off:
  - Reset may take **several cycles** to fully propagate
  - Similar to handling resets in **multi-clock designs**

[.notes]
--
Patrón práctico: registrar `reset_raw` por nivel.  
Aceptamos latencia de propagación a cambio de fanout razonable y timing local sencillo.
--

=== Asynchronous Reset Distribution

[%step]
* Technique: use a **distributed reset synchronizer** at each hierarchy level
  - 2 FFs per synchronizer (async assert, sync de-assert)
  - Local reset drives **async reset pins** directly

[%step]
* Characteristics:
  - Reset asserted immediately (async)
  - Reset released gradually across multiple clock cycles
  - Removes need for manual timing fixes after P&R

[%step]
* Considerations:
  - Design must tolerate **staggered release**
  - Proper tool settings required to check **recovery/removal** timing
  - Especially useful in **FPGA** designs:
    • Avoids LUT usage from sync resets  
    • Works with limited Global Set/Reset resources

[.notes]
--
La versión distribuida del sincronizador evita ajustes manuales de backend y se adapta muy bien a FPGA.  
Eso sí, verificad que el sistema tolera un release escalonado entre bloques.
--

=== Reset tree timing (visual)

image::rst_sync_tree.png[width=500,align=center]

[.notes]
--
Diagrama para reforzar: el release viaja por niveles; cada nivel entrega un reset local que cumple recovery en su propio dominio.
--

== Reset-Glitch Filtering

[%step]
* Problem: **asynchronous resets** are sensitive to glitches
  - Any pulse wider than min. reset width will reset the FF

[%step]
* Possible solution: **digital delay filter**
  - Delay line filters out short glitches
  - Requires Schmitt-trigger input pad
  - Vendor hard-macro or hand-instantiated delay

[%step]
* Caveats:
  - Delay varies with **PVT (process, voltage, temperature)**
  - Must use *dont_touch* or equivalent to prevent optimization
  - Only needed in systems with noisy reset sources

[.notes]
--
Si el reset de placa es ruidoso, se puede filtrar con retardo digital + pad Schmitt.  
Es un apaño dependiente de PVT: último recurso; mejor arreglar el origen del ruido si es posible.
--

== Multi-Clock Reset Issues

=== General

[%step]
* Each **clock domain** needs its own:
  - Asynchronous reset synchronizer
  - Reset distribution tree

[%step]
* **Assertion** of reset is safe → affects all domains immediately
* **Removal** of reset is the challenge:
  - Must ensure recovery time per domain
  - Avoid unsynchronized startup

[%step]
* Two possible approaches:
  1) **Non-coordinated** reset removal (each domain independently)
  2) **Sequenced** coordination (controlled release across domains)

[.notes]
--
Un sincronizador por dominio de reloj.  
La afirmación simultánea no es problema; la desactivación debe estar coordinada con el reloj local y, si hace falta, con el orden de arranque.
--

=== Non-Coordinated Reset Removal

[%step]
* In many **multi-clock designs**, the exact moment of reset removal per domain **does not matter**
* Safe when **cross-domain communication** uses:
  - Request/Acknowledge handshaking
  - Delay in acks does not cause invalid execution

[%step]
* Solution:
  - Use **independent asynchronous reset synchronizers**
  - Each clock domain (A, B, C…) has its own reset (arst_n, brst_n, crst_n)
  - Removal sequence/order is irrelevant

[.notes]
--
Si todos los cruces usan handshake, el orden de salida de reset por dominios no es crítico.  
Basta con un sincronizador independiente en cada dominio.
--

=== Sequenced Reset Removal

[%step]
* Some **multi-clock designs** require **ordered** reset removal
* Example:
  - aclk logic must start **before** bclk logic
  - bclk logic must start **before** cclk logic

[%step]
* Solution:
  - Use **prioritized asynchronous reset synchronizers**
  - Highest priority reset input tied **high**
  - Lower domains’ resets chained to **master resets** from higher domains

[.notes]
--
Cuando hay dependencias duras (p.ej., memoria/PLL antes que fabric), encadenamos los “master resets” para imponer el orden de arranque.
--

== Conclusions

[%step]
* Both **synchronous** and **asynchronous resets** can guarantee safe initialization
* Biggest challenge → **asynchronous reset removal** (risk of metastability)
* Recommended:
  - Use **reset synchronizer logic**
  - Ensure **synchronous removal** after async assertion
* DFT with async resets is possible if reset is **controllable during test**
* Distributed reset flip-flop trees help with **buffering, timing & layout**

[.text-center]
*In short: simple little resets... aren’t!* ⚡

[.notes]
--
Cierro con tres ideas:  
(1) Ambos estilos son válidos si gestionáis sus riesgos.  
(2) En asíncrono, el sincronizador de 2 FFs no es opcional.  
(3) Pensad en distribución y temporización del reset como pensáis en el reloj.
--

== References

* *Asynchronous & Synchronous Reset Design Techniques – Part Deux*  
  Clifford E. Cummings, Don Mills, Steve Golson

* *DC Synopsys User Guide*

* *HDL Compiler™ for SystemVerilog – User Guide*

[.notes]
--
Estas son buenas lecturas para profundizar: técnica, directivas y checks de temporización.  
Si sólo podéis leer una sección, id a recovery/removal y a los patrones de sincronización de reset.
--
