include::_common.adoc[]
:imagesdir: ./private_imgs/sesion1

== Reset Strategies in Digital Design

[.text-center]
**Simple in appearance, complex in practice**

== Reset Design — Motivation and Background

[.text-justify]
**Reset design** is a surprisingly complex topic that is often **poorly emphasized** in engineering education.

[.text-justify]
- Improper reset strategies can lead to **real design failures**.
- Industry experience shows that reset handling is often **underestimated**.

[.notes]
--
El diseño del reset es un tema complejo y a menudo poco enfatizado en la educación.
Errores en el reset pueden causar fallos reales en el diseño.
La experiencia en la industria muestra que a menudo se subestima su importancia.
--

== Synchronous vs. Asynchronous Resets

[.text-justify]
The choice between **synchronous** and **asynchronous** resets has become almost a *religious debate*  
in the hardware design community.

[.text-justify]
- Both approaches are valid — each with **strengths and weaknesses**
- The key is to understand **when and how** to apply each method properly.

[.notes]
--
La elección entre resets síncronos y asíncronos es un tema que genera mucho debate.
Ambos enfoques son válidos, cada uno con sus ventajas y desventajas.
Lo importante es entender cuándo y cómo aplicar cada método correctamente.
--

== Why Resets Matter

[.text-justify]
**Why care about these annoying little resets?**  
Because they bring a system back to a **known working state** — and that can be the difference between recovery and failure.

[.text-justify]
- A **hardware reset** initializes every chip in a system to a stable condition.
- Even in PCs, the **reset button** is often the most reliable “fix” when things go wrong.
- In ASICs, resets ensure that simulation, synthesis, and silicon all **start from a predictable state**.

[.text-justify]
A well-designed reset system ensures **functional correctness, reproducibility, and testability**.

[.notes]
--
¿Por qué preocuparnos por los resets? Porque permiten volver a un estado conocido, lo que puede ser la diferencia entre recuperación y fallo.
Un buen sistema de reset asegura corrección funcional, reproducibilidad y testabilidad.
--

== The Purpose of Reset in ASICs

[.text-justify]
For ASICs, the reset has one primary goal:  
**force the design into a known state** for simulation and reliable startup.

[.text-justify]
- Some ASICs (e.g., data-path or communication designs) can **self-synchronize** without resets.
- However, most designs require at least a **power-up reset** to ensure all logic starts correctly.
- Even unused states in FSMs should point to a **safe initialization path**.

[.text-justify]
In general:
- Every flip-flop **should be resettable**, even if not always used by the system.
- High-speed pipelines may **omit resets** to meet timing.
- Designers must plan **reset trees**, buffering, and verification with care.

[.notes]
--
No todos los chips necesitan un reset externo para funcionar, pero casi todos lo agradecen para arrancar de forma determinista.
En datapaths, si las FSMs están bien diseñadas, pueden re-sincronizarse; aún así, el resto del sistema debe quedar en estado seguro.
Como regla, reseteamos todo; excepción: followers de pipelines críticos para frecuencia.
Además del estilo, hay que diseñar el árbol de distribución, verificar recovery/removal, contemplar DFT y pensar en dominios de reloj múltiples.
--

== General Flip-Flop Coding — Bad Practice

[.text-justify]
Each Verilog procedural block should **model only one type of flip-flop**.  
Mixing **resettable** and **non-resettable** (follower) flops in the same block leads to **unwanted logic**.

[.text-justify]
- A *follower flip-flop* is a simple data shift register with no reset.
- When both are coded together, the reset signal may be **interpreted as a data enable** for the follower stage.
- This results in **extra combinational logic**, as it is shown.

[cols="50a,50a"]
|===
| 
[source,verilog]
----
module badFFstyle (
  input  logic clk, 
  input  logic rst_n, 
  input  logic d,
  output logic q2
);
  logic q1;
  always_ff @(posedge clk)
    if (!rst_n)
      q1 <= 1'b0;
    else begin
      q1 <= d;
      q2 <= q1;
    end
endmodule
----
| 
image::bad_ff_style.svg[width=90%]
|===


[.small-text]
Bad Verilog coding style: mixing resettable and follower flip-flops.

== Correct Flip-Flop Coding Style

[.text-justify]
To avoid unintended logic, model **each flip-flop type** in its **own procedural block**.

[.text-justify]
- Separate resettable and non-resettable flops.
- This style produces **clean synthesis results**, as it is shown below.
- If asynchronous resets were used, both coding styles would synthesize identically.

[cols="50a,50a"]
|===
| 
[source,verilog]
----
module goodFFstyle (
  input  logic clk, 
  input  logic rst_n, 
  input  logic d,
  output logic q2
);
  logic q1;

  // Resettable flip-flop
  always_ff @(posedge clk)
    if (!rst_n)
      q1 <= 1'b0;
    else
      q1 <= d;

  // Follower flip-flop
  always_ff @(posedge clk)
    q2 <= q1;
endmodule
----
----
| 
image::good_ff_style.svg[width=90%]
|===

[.small-text]
Good Verilog style: separate processes for different flip-flop types.


== Flip-Flop Inference Style

[.text-justify]
When modeling flip-flops in RTL, **inference style** is key for readability and synthesis efficiency.

[.text-justify]
- All **inferred flip-flops of a common function** (or group of related functions)  
  should be described in **a single procedural block** (`always` or `process`).
- Use **multiple blocks** only for **larger partitioned functional groups**.

[.text-justify]
This ensures:
- Consistent **reset behavior** and **timing grouping**
- Simplified **simulation and synthesis**
- Cleaner and more **maintainable RTL**

https://github.com/lowRISC/ibex/blob/master/rtl/ibex_if_stage.sv#L498


[.notes]
--
El estilo de inferencia es clave para la legibilidad y eficiencia de síntesis.
Agrupad flops relacionados en un mismo bloque `always_ff` para mantener consistencia en reset y timing.
Usad múltiples bloques sólo para grupos funcionales grandes y separados.  s
Esto facilita la simulación, síntesis y mantenimiento del RTL.
--






== ⏱ Synchronous Resets

=== Concept

[.text-justify]
* Reset **only takes effect** on the active clock edge
* Implemented as part of the **combinational logic** feeding *D*

[.text-justify]
* Coding style → `if (reset)` has **highest priority**
* Otherwise: risk of
  - Reset blocked in simulation
  - **Late arrival** of reset (high fanout in reset tree)

[.text-justify]
* Even with reset buffer trees → **Minimize logic delay** after the reset reaches local logic
* Works with **any logic library**

[.notes]
--
En síncrono, el reset se evalúa en el flanco de reloj; el reloj actúa como filtro natural de glitches.  
Codificad siempre el reset primero en el `if`. Limitad la lógica tras el reset local, porque el árbol suele tener gran fanout.
--

=== Example: Counter (sync reset)

[%notitle,stretch]
[source,systemverilog]
----
module ctr8sr (
  input  logic        clk,
  input  logic        rst_n,  // active low reset
  input  logic        load,
  input  logic [7:0]  d,
  output logic [7:0]  q,
  output logic        co
);
  always_ff @(posedge clk) begin
    if (!rst_n)         // sync reset
      {co,q} <= '0;
    else if (load)      // sync load
      {co,q} <= d;
    else                // sync increment
      {co,q} <= q + 1'b1;
  end
endmodule
----
*Loadable counter with synchronous reset*

[.notes]
--
Ejemplo canónico: prioridad al reset, luego al load, y por último al incremento.  
Fijaos que el reset viaja como dato hasta el D del flop: esto influye en inferencia y temporización.
--

=== Example circuit 1

image::count_sync_rst.0.png[width=800,align=center]

[.notes]
--
Aquí se ve cómo la herramienta interpreta el reset como parte de la lógica de datos.  
Esto puede confundir la inferencia si no marcamos la intención.
--

=== Is this signal a reset?

* One problem with the sync reset is that the **synthesis tool** cannot easily distinguish the reset signal from other data signals.

[.notes]
--
Mensaje: para el sintetizador, un “if (reset)” es lógica como cualquier otra.  
Conviene ayudar con directivas si queréis un tratamiento específico.
--

=== Example circuit 2

image::count_sync_rst.1.png[width=500,align=center]

[.notes]
--
Después de inferencia, vemos cómo se inserta la selección entre reset y dato.  
Esto explica el posible impacto en profundidad lógica de la ruta de datos.
--

=== Synopsys: Reset Logic Inference

* To enable the tool to recognize reset signals and infer proper reset logic, you can use:
  - `sync_set_reset` directive
  - `hdlin_ff_always_sync_set_reset` variable

[.notes]
--
En Synopsys, estas opciones facilitan que el reset se identifique e infiera como tal.  
Aun así, base fundamental: estilo de codificación limpio, con reset de mayor prioridad.
--

=== Advantages of synchronous resets (Part I)

* Flip-flops with synchronous reset can be smaller → reset logic merged into D-input
* Generally ensures the circuit is **100% synchronous**
* Reset only occurs on a clock edge → clock filters small glitches
  - This is no different than other data inputs; any signal that violates setup can cause metastability

[.notes]
--
Ventaja clave: diseño completamente síncrono y con filtro natural de glitches.  
El tamaño del flop puede ser menor si la librería no necesita pin dedicado.
--

=== Advantages of synchronous resets (Part II)

* Useful when reset must be generated by **internal conditions** → filters combinational glitches
* Reset buffer tree can use **flip-flops** → helps timing within a clock period
* Claimed to be easier in cycle-based simulators
  - But with good testbench practice, advantage is minimal
* Overall: robust, but not always decisive for area or simulation speed

[.notes]
--
Si vuestro reset viene de lógica interna, el estilo síncrono ayuda a filtrar transitorios.  
El árbol puede “registrarse” por niveles y simplificar timing; la ventaja en simulación es secundaria si el TB está bien escrito.
--

=== ⚠ Disadvantages of synchronous resets (Part I)

[.text-center]
* Not all libraries include flip-flops with built-in sync reset  
  - However, since sync reset is just another data input, you don’t really need a special flop
* May need a **pulse stretcher** to guarantee reset width across clock edges
  - Important in multi-clock design: a small counter can guarantee N cycles of reset

[.notes]
--
Si el pulso de reset es estrecho, puede no coincidir con ningún flanco: estiradlo con un pequeño contador.  
No dependáis de supuestos optimistas sobre anchura de pulso.
--

=== ⚠ Disadvantages of synchronous resets (Part II)

* In simulation, resets can be masked by **X-propagation** through logic
* Requires a **clock** to take effect → problematic with gated clocks or no clock running
* On power-up with **tristate buses**, async reset is safer (avoids contention)

[.notes]
--
Con relojes parados o con gating, el reset síncrono puede no surtir efecto a tiempo.  
En buses triestado al encender, el asíncrono evita contenciones antes del primer flanco útil.
--

=== ⚠ On power-up with tristate buses

image::rst_buf_tris.png[width=700,align=center]

[.notes]
--
Si mantenéis estilo síncrono, desactivad directamente las salidas triestado con el reset para garantizar alta impedancia desde el arranque.
--

== ⏱ Asynchronous Resets

=== Concept & risks

[.text-center]
* Commonly used because reset acts **immediately**, independent of clock
* Flip-flops usually provide a **dedicated reset pin** (typically active-low)
* Ensures logic goes to a **known state** as soon as reset is asserted

[.text-center]
* Main issue: **reset release / removal**
  - If not handled properly → risk of metastability & design failures
* Sensitive to timing between **reset de-assertion** and **clock edges**
* Requires careful design practices

[.notes]
--
La gran ventaja es la inmediatez; el gran riesgo es la desactivación cerca del flanco de reloj.  
Ahí es donde aparece la metastabilidad si no se sincroniza correctamente.
--

=== Coding Style for Async Reset

[.text-center]
* Reset must be part of the **sensitivity list**
* Sensitivity only to:
  - **Clock edge**
  - **Reset edge**
* Reset has **priority** (if/else style); avoid extra signals in the sensitivity list

[.notes]
--
Usad `always_ff @(posedge clk or negedge rst_n)` para activo-bajo.  
Sólo reloj y reset en la lista; el reset en el `if` con prioridad máxima.
--

=== Example: Async Reset Flip-Flop

[source,systemverilog]
----
module async_resetFFstyle (
  output logic q,
  input  logic d, clk, rst_n
);

always_ff @(posedge clk or negedge rst_n) begin
  if (!rst_n)
    q <= 1'b0;      // async reset
  else
    q <= d;         // normal operation
end

endmodule
----

[.notes]
--
Ejemplo directo de estilo correcto.  
Observad que el comportamiento de reset no depende del reloj para **entrar** en reset, pero sí sincronizaremos la **salida** de reset después.
--

=== Async Reset in Synthesis (Synopsys DC)

[.text-center]
* Reset nets must be **protected** from optimization
* If reset comes from an **external pin**:
  - `set_drive 0 [get_ports reset]`
  - `set_dont_touch_network [get_nets reset]`

[.text-center]
* Alternative approaches:
  - `set_resistance 0 [get_nets reset]`
  - Custom *wireload model* with `resistance=0`
  - `set_ideal_net reset` (post-2001.08)

[.text-center]
* To clean timing reports:
  - `set_disable_timing [get_nets reset]`
  - `set_false_path -from [get_ports reset]`

[.text-center]
⚠️ Goal: Ensure reset nets are **not modified** and do not introduce false timing violations

[.notes]
--
Proteger la red de reset para que el sintetizador no la “optimice”.  
Además, limpiad informes con `false_path` o `disable_timing` donde tenga sentido, evitando falsos positivos.
--

=== Advantages of Async Resets

[.text-center]
* **Timing advantage** → No extra gates/net delays in the **data path**
* **Independent of clock** → Can reset even when clock is absent
* **Synthesis-friendly** with proper coding style

[.notes]
--
Si vais justos de timing en el datapath, el asíncrono evita meter puertas extra.  
Además permite resetear subsistemas aunque su reloj aún no esté activo.
--

=== Disadvantages of Async Resets

[.text-center]
* **DFT concern** → If not driven from I/O pin, reset nets must be disabled for scan/testing
* **Static Timing Analysis complexity**
  - Reset tree checked for both async & sync timing, especially **after layout**
  - This can be reduced using a **distributed reset synchronizer** tree

[.text-center]
* **De-assertion hazard** → near active clock edge → **metastability**
* **Noise sensitivity** → glitches may cause spurious resets
* Remember: **assertion is safe; de-assertion is the real problem**

[.notes]
--
La clave: sincronizar la **salida** del reset para evitar metastabilidad.  
En STA, aseguraos de habilitar arcos de recovery/removal y revisar tras P&R.
--

== Asynchronous Reset Problem

=== Reality check

[.text-center]
* Common **misconception**: “FPGAs don’t have the same reset issues as ASICs” ❌
* Truth: **Both FPGA and ASIC** can fail if reset is released near a clock edge
* Flip-flops can go **metastable** → reset loses its purpose

[.notes]
--
Esto no es un “problema sólo de ASICs”.  
Las FPGAs sufren exactamente el mismo riesgo de metastabilidad si sueltas el reset cerca del flanco.
--

=== Simulation vs. Silicon

[.text-center]
* In **simulation** → reset always works (controlled environment)
* In **real system** → reset release can occur close to clk edge
* Result: **intermittent, hard-to-debug failures**; system may enter an **unknown state**

[.notes]
--
La sim no reproduce jitter/ruido real.  
En hardware aparecen fallos intermitentes y difíciles de reproducir: síntoma típico de un release mal sincronizado.
--

=== Key Lesson

[.text-center]
* Reset release must be carefully controlled; avoid de-assertion near clock edges
* Applies to both:
  - **Asynchronous resets**
  - **Synchronous resets** (must keep edges away from clk)

[.notes]
--
Mensaje para llevarse: controlad la salida de reset.  
Incluso en síncrono, aseguraos de que los bordes no caen justo en el flanco activo.
--

== Timing Considerations

=== Reset Recovery Time

[.text-center]
* Time between **reset de-assertion** and next **clock edge**
* Equivalent to a **setup time (tsu)**: Reset inactive setup before CLK↑

[.text-center]
* If violated → signal integrity issues and **metastability** in FF outputs

[.text-center]
* SystemVerilog (IEEE 1800-2017) supports checks:
  - `$recovery`, `$removal`, `$recrem`

[.notes]
--
El “recovery” es como un setup del reset respecto al flanco.  
Usad `$recovery/$removal/$recrem` para chequear que estáis dentro de margen.
--

=== Reset Removal Across Flip-Flops

[.text-center]
* When reset removal is **asynchronous** to clk, small differences in propagation (reset vs. clk) →
* Some flip-flops leave reset **earlier than others**
* Risk: registers exit reset state in **different clock cycles**

[.notes]
--
Pequeñas diferencias de ruta pueden hacer que unos FF salgan de reset uno o dos ciclos antes que otros.  
Si no lo tenéis en cuenta, podéis arrancar el sistema en un estado inconsistente.
--

== Reset Synchronizer

=== Why?

[.text-center]
* Async resets **work in sim**… but may fail in hardware on de-assertion
* Need **async assert** + **sync de-assert**
* Standard solution: **2-FF reset synchronizer**

[.notes]
--
Patrón universal: 2 FFs en serie por dominio de reloj para “entregar” el release alineado al flanco.  
Así mantenemos la rapidez del asíncrono al entrar y la seguridad del síncrono al salir.
--

=== Circuit

image::rst_sync.png[width=500,align=center]

[.text-center]
* External reset asynchronously resets two FFs
* These FFs drive the **master reset** across the design
* De-assertion is synchronized → requires **2 clock cycles**
* Second FF protects against metastability
* Synchronizer FFs must be kept **off scan chain**

[.notes]
--
Primer FF puede quedar meta si el release cae cerca del flanco; el segundo absorbe ese meta.  
Recordad: excluid estos FFs del scan o tratadlos como “safe” en DFT.
--

=== Timing

image::rst_sync_II.png[width=500,align=center]

* Reset distribution timing is the sum of **clk→q** propagation delay + **reset tree delay** + **recovery time**

[.notes]
--
Para que todos salgan seguros, la suma clk→q del sincronizador, más el retardo del árbol, más el recovery en destino, debe cumplir margen.  
Esto se verifica tras P&R.
--

=== Timing (summary)

[.text-center]
* Reset distribution timing = **clk→q delay** + **reset tree delay** + **reset recovery time**
* Ensures all destination FFs see reset release **safely aligned**
* Avoids asynchronous hazards across reset tree

[.notes]
--
Resumen visual: liberamos reset de forma síncrona y lo distribuimos cumpliendo recovery en todos los endpoints.  
Así evitamos salidas descoordinadas del reset.
--

=== Lab idea

* Run a simulation **without** a reset synchronizer, using async-reset FFs
* De-assert reset near a clk edge and observe behavior vs. **with** synchronizer

[.notes]
--
Demostración rápida: sin sincronizador veréis X’s/glitches en salidas; con 2 FFs, el arranque es repetible y limpio.  
Ideal para “vender” internamente la necesidad del patrón.
--

== Reset Distribution Tree

=== Overview

[.text-center]
* The **reset distribution tree** needs almost as much care as the **clock tree**
* Typically, there are as many reset loads as clock loads
* Key difference:
  - Clock skew must be tightly controlled
  - Reset skew is less critical — but **must still meet recovery time**
* Design tip:
  - Always analyze **clock vs. reset timing**
  - Reset should not violate setup/hold on flip-flops
* Ignoring reset tree design can lead to **unpredictable behavior**

[.notes]
--
El árbol de reset no exige skew tan ajustado como el de reloj, pero sí llegar a tiempo para cumplir recovery.  
Comparad rutas de reloj y reset y evitad violaciones de setup/hold en destinos.
--

=== Synchronous Reset Distribution

[.text-center]
* Technique: build a **distributed reset tree** with embedded flip-flops
* Each module:
  - Receives a raw reset (`reset_raw`)
  - Registers it once with the local clock
  - Uses the registered signal (`reset`) inside the module and passes it down

[.text-center]
* Advantages:
  - No need to reach all FFs in one clock cycle
  - Reset treated like any other **data signal**
  - Simplifies **timing analysis** and keeps fanout reasonable
* Trade-off:
  - Reset may take **several cycles** to fully propagate
  - Similar to handling resets in **multi-clock designs**

[.notes]
--
Patrón práctico: registrar `reset_raw` por nivel.  
Aceptamos latencia de propagación a cambio de fanout razonable y timing local sencillo.
--

=== Asynchronous Reset Distribution

[.text-center]
* Technique: use a **distributed reset synchronizer** at each hierarchy level
  - 2 FFs per synchronizer (async assert, sync de-assert)
  - Local reset drives **async reset pins** directly

[.text-center]
* Characteristics:
  - Reset asserted immediately (async)
  - Reset released gradually across multiple clock cycles
  - Removes need for manual timing fixes after P&R

[.text-center]
* Considerations:
  - Design must tolerate **staggered release**
  - Proper tool settings required to check **recovery/removal** timing
  - Especially useful in **FPGA** designs:
    • Avoids LUT usage from sync resets  
    • Works with limited Global Set/Reset resources

[.notes]
--
La versión distribuida del sincronizador evita ajustes manuales de backend y se adapta muy bien a FPGA.  
Eso sí, verificad que el sistema tolera un release escalonado entre bloques.
--

=== Reset tree timing (visual)

image::rst_sync_tree.png[width=500,align=center]

[.notes]
--
Diagrama para reforzar: el release viaja por niveles; cada nivel entrega un reset local que cumple recovery en su propio dominio.
--

== Reset-Glitch Filtering

[.text-center]
* Problem: **asynchronous resets** are sensitive to glitches
  - Any pulse wider than min. reset width will reset the FF

[.text-center]
* Possible solution: **digital delay filter**
  - Delay line filters out short glitches
  - Requires Schmitt-trigger input pad
  - Vendor hard-macro or hand-instantiated delay

[.text-center]
* Caveats:
  - Delay varies with **PVT (process, voltage, temperature)**
  - Must use *dont_touch* or equivalent to prevent optimization
  - Only needed in systems with noisy reset sources

[.notes]
--
Si el reset de placa es ruidoso, se puede filtrar con retardo digital + pad Schmitt.  
Es un apaño dependiente de PVT: último recurso; mejor arreglar el origen del ruido si es posible.
--

== Multi-Clock Reset Issues

=== General

[.text-center]
* Each **clock domain** needs its own:
  - Asynchronous reset synchronizer
  - Reset distribution tree

[.text-center]
* **Assertion** of reset is safe → affects all domains immediately
* **Removal** of reset is the challenge:
  - Must ensure recovery time per domain
  - Avoid unsynchronized startup

[.text-center]
* Two possible approaches:
  1) **Non-coordinated** reset removal (each domain independently)
  2) **Sequenced** coordination (controlled release across domains)

[.notes]
--
Un sincronizador por dominio de reloj.  
La afirmación simultánea no es problema; la desactivación debe estar coordinada con el reloj local y, si hace falta, con el orden de arranque.
--

=== Non-Coordinated Reset Removal

[.text-center]
* In many **multi-clock designs**, the exact moment of reset removal per domain **does not matter**
* Safe when **cross-domain communication** uses:
  - Request/Acknowledge handshaking
  - Delay in acks does not cause invalid execution

[.text-center]
* Solution:
  - Use **independent asynchronous reset synchronizers**
  - Each clock domain (A, B, C…) has its own reset (arst_n, brst_n, crst_n)
  - Removal sequence/order is irrelevant

[.notes]
--
Si todos los cruces usan handshake, el orden de salida de reset por dominios no es crítico.  
Basta con un sincronizador independiente en cada dominio.
--

=== Sequenced Reset Removal

[.text-center]
* Some **multi-clock designs** require **ordered** reset removal
* Example:
  - aclk logic must start **before** bclk logic
  - bclk logic must start **before** cclk logic

[.text-center]
* Solution:
  - Use **prioritized asynchronous reset synchronizers**
  - Highest priority reset input tied **high**
  - Lower domains’ resets chained to **master resets** from higher domains

[.notes]
--
Cuando hay dependencias duras (p.ej., memoria/PLL antes que fabric), encadenamos los “master resets” para imponer el orden de arranque.
--

== Conclusions

[.text-center]
* Both **synchronous** and **asynchronous resets** can guarantee safe initialization
* Biggest challenge → **asynchronous reset removal** (risk of metastability)
* Recommended:
  - Use **reset synchronizer logic**
  - Ensure **synchronous removal** after async assertion
* DFT with async resets is possible if reset is **controllable during test**
* Distributed reset flip-flop trees help with **buffering, timing & layout**

[.text-center]
*In short: simple little resets... aren’t!* ⚡

[.notes]
--
Cierro con tres ideas:  
(1) Ambos estilos son válidos si gestionáis sus riesgos.  
(2) En asíncrono, el sincronizador de 2 FFs no es opcional.  
(3) Pensad en distribución y temporización del reset como pensáis en el reloj.
--

== References

* *Asynchronous & Synchronous Reset Design Techniques – Part Deux*  
  Clifford E. Cummings, Don Mills, Steve Golson

* *DC Synopsys User Guide*

* *HDL Compiler™ for SystemVerilog – User Guide*

[.notes]
--
Estas son buenas lecturas para profundizar: técnica, directivas y checks de temporización.  
Si sólo podéis leer una sección, id a recovery/removal y a los patrones de sincronización de reset.
--
